<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta name="description" content="数据的读取（缓冲池、顺序读取与随机读取）在学习索引之前，我们先探讨一下数据库中的数据是怎么读取的。根据存储介质的不同，可以将数据库分为基于磁盘的数据库系统、基于内存的数据库系统，以及混合型数据库系统。毫无疑问，基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。磁盘的速度要远慢于内存的速度，因此基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小数据—称为">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL中的索引——原理及优化">
<meta property="og:url" content="http://example.com/2021/04/01/MySQL09_MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="Saltedfish">
<meta property="og:description" content="数据的读取（缓冲池、顺序读取与随机读取）在学习索引之前，我们先探讨一下数据库中的数据是怎么读取的。根据存储介质的不同，可以将数据库分为基于磁盘的数据库系统、基于内存的数据库系统，以及混合型数据库系统。毫无疑问，基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。磁盘的速度要远慢于内存的速度，因此基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小数据—称为">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-1.png">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-2.png">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-3.png">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-4.png">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-5.png">
<meta property="og:image" content="d:/hexoBlog/source_posts/MySQL/09-6.png">
<meta property="article:published_time" content="2021-03-31T17:12:45.000Z">
<meta property="article:modified_time" content="2021-07-25T08:54:10.885Z">
<meta property="article:author" content="Saltedfish">
<meta property="article:tag" content="InnoDB">
<meta property="article:tag" content="索引">
<meta property="article:tag" content="B+树">
<meta property="article:tag" content="索引优化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="d:/hexoBlog/source_posts/MySQL/09-1.png">


<link rel="canonical" href="http://example.com/2021/04/01/MySQL09_MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<title>MySQL中的索引——原理及优化 | Saltedfish</title><script data-pjax src="/js/load-config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Saltedfish</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of saltedfish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">156</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">85</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%8F%96%EF%BC%88%E7%BC%93%E5%86%B2%E6%B1%A0%E3%80%81%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%8F%96%E4%B8%8E%E9%9A%8F%E6%9C%BA%E8%AF%BB%E5%8F%96%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">数据的读取（缓冲池、顺序读取与随机读取）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-number">2.</span> <span class="nav-text">索引是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%BA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.</span> <span class="nav-text">索引的本质为数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">优缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-%E6%A0%91%E4%BD%9C%E4%B8%BAMySQL%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A0%91%E2%80%94%E2%80%94%E4%BB%8E%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%B0B%E6%A0%91%E5%86%8D%E5%88%B0B-%E6%A0%91"><span class="nav-number">2.2.</span> <span class="nav-text">为什么选择B+树作为MySQL的索引树——从平衡二叉树到B树再到B+树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">2.2.1.</span> <span class="nav-text">平衡二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E5%8C%BA%E5%88%AB%EF%BC%8CB-%E6%A0%91%E7%9B%B8%E6%AF%94B%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="nav-number">2.2.2.</span> <span class="nav-text">B树和B+树区别，B+树相比B树的优点？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQl%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BD%93%E7%8E%B0%E5%BD%A2%E5%BC%8F%E2%80%94%E2%80%94MyISAM-%E5%92%8C-InnoDB"><span class="nav-number">2.3.</span> <span class="nav-text">MySQl中的索引体现形式——MyISAM 和 InnoDB</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MyISAM%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="nav-number">2.4.</span> <span class="nav-text">MyISAM中的索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InooDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%88%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="nav-number">2.5.</span> <span class="nav-text">InooDB中的索引（聚集索引和辅助索引）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%A5%E4%B8%8D%E8%AF%A5%E5%BB%BA%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="nav-number">3.1.</span> <span class="nav-text">该不该建索引？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.</span> <span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.</span> <span class="nav-text">覆盖索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#INDEX-HINT%EF%BC%88%E7%B4%A2%E5%BC%95%E6%8F%90%E7%A4%BA%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">INDEX HINT（索引提示）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Multi-Range-Read-MMR"><span class="nav-number">3.5.</span> <span class="nav-text">Multi-Range Read(MMR)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Index-Condition-Pushdown-ICP"><span class="nav-number">3.6.</span> <span class="nav-text">Index Condition Pushdown(ICP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%93%E6%B2%B9%E8%AF%97%EF%BC%88%E5%8F%A3%E8%AF%80%EF%BC%89"><span class="nav-number">3.7.</span> <span class="nav-text">打油诗（口诀）</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Saltedfish"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Saltedfish</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/01/MySQL09_MySQL%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Saltedfish">
      <meta itemprop="description" content="Stay hungry, stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saltedfish">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL中的索引——原理及优化
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-04-01 01:12:45" itemprop="dateCreated datePublished" datetime="2021-04-01T01:12:45+08:00">2021-04-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-07-25 16:54:10" itemprop="dateModified" datetime="2021-07-25T16:54:10+08:00">2021-07-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="数据的读取（缓冲池、顺序读取与随机读取）"><a href="#数据的读取（缓冲池、顺序读取与随机读取）" class="headerlink" title="数据的读取（缓冲池、顺序读取与随机读取）"></a>数据的读取（缓冲池、顺序读取与随机读取）</h2><p>在学习索引之前，我们先探讨一下数据库中的数据是怎么读取的。根据存储介质的不同，可以将数据库分为基于磁盘的数据库系统、基于内存的数据库系统，以及混合型数据库系统。毫无疑问，基于内存的数据库系统是最快的，因为数据库不需要对磁盘进行操作。磁盘的速度要远慢于内存的速度，因此基于磁盘的数据库系统一般都有缓冲池，即一块内存区域，其作用是将从磁盘上读取的指定大小数据—称为页（或块）放入缓冲池，当再次读取时，数据库首先判断该页是否在缓冲池中，如果在则直接读取缓冲池中的页，如果不在则读取磁盘上的页。对于写操作，数据库将页读入缓冲池，然后在缓冲池中对页进行修改，修改完成后的页一般被异步地写入磁盘上。对于缓冲池的维护一般采用最近最少使用（Least Recently Used，LRU）算法。通过缓冲池避免频繁的磁盘IO，可以加快读取的速度。<span id="more"></span></p>
<p>对于MySQL数据库系统，由于其有着各种不同的存储引擎，因此其缓冲池是基于存储引擎的，也就是说每个存储引擎都有自己的缓冲池。显而易见，在生产环境中缓冲池的大小肯定小于数据文件的大小，因此不可避免地存在磁盘的读取操作，<strong>但是传统的机械硬盘的特性决定了顺序读取要远快于离散读取</strong>。机械硬盘读取数据是靠磁头的转动或者移动来实现的，如果是<code>顺序读取</code>，磁头只需要顺序转动即可，而如果是<code>随机读取</code>，那么磁头需要频繁的移动，显然会慢很多。注意这里的“顺序”指的是逻辑上的顺序，在物理上不可能保证所有的数据都是顺序的。对于固态硬盘而言，它没有任何的读写磁头等移动部件，因此固态硬盘有着较低的访问延时。当主机发布一个读写请求时，固态硬盘的控制器会把I/O命令从逻辑地址映射到实际的物理地址，写操作还需要修改相应的映射表信息即使是固态硬盘，顺序读取还是要快于随机读取。总之顺序读取要快于随机读取。</p>
<p>因为顺序读取要快于随机读取，那么我们组织数据的时候就应该把有序的数据放在一块，但怎么定义有序哪？有那么多列，按哪一列的值定义？索引就是解决这个问题的。</p>
<h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><h3 id="索引的本质为数据结构"><a href="#索引的本质为数据结构" class="headerlink" title="索引的本质为数据结构"></a>索引的本质为数据结构</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>MySQL官方对索引的定义：索引（Index）是帮助MySQL 高效获取数据的数据结构。可以得到索引的本质是数据结构，可以简单理解为<strong>排好序的快速查找数据结构</strong>。这种数据结构往往空间很大，是存在硬盘里的，又称为磁盘级索引。</p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>优势： </p>
<ul>
<li>提高数据检索的效率，降低数据库的IO成本。 </li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li>
</ul>
<p>劣势： </p>
<ul>
<li>虽然索引提高了查询速度，但同时会降低更新表的速度。在更新表时，MySQL不仅要更新数据，也要维护索引，调整因为更新所带来的键值变化后的索引信息（所以说在频繁更新的列上不建议建索引）。</li>
<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。</li>
</ul>
<h3 id="为什么选择B-树作为MySQL的索引树——从平衡二叉树到B树再到B-树"><a href="#为什么选择B-树作为MySQL的索引树——从平衡二叉树到B树再到B-树" class="headerlink" title="为什么选择B+树作为MySQL的索引树——从平衡二叉树到B树再到B+树"></a>为什么选择B+树作为MySQL的索引树——从平衡二叉树到B树再到B+树</h3><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><img src="D:\hexoBlog\source_posts\MySQL\09-1.png"></p>
<p>一般的索引树的结构如上，每个节点占用一个<code>磁盘块</code>，一个节点（磁盘块）里主要包含<code>关键字</code>、<code>数据区</code>、<code>子节点引用</code>；需要注意的是数据区常规的设计有两种，一种是直接保存物理数据，另外一种设计是保存指向真正物理数据的地址。而且内存或者操作系统在磁盘进行IO读取的时候，是以页为单位的，一页为4K，所以一般一个磁盘块最少为4K。</p>
<ul>
<li>为什么不选平衡二叉树？<ul>
<li>二叉树只有一个键值，简而言之它是二路的，所以它的深度是 logn 的，树的深度决定着IO的次数，搜索效率较低，会耗费较多的IO时间</li>
<li>因为它只有一个键值，磁盘块的空间利用不足，没有很好地利用操作系统和磁盘的数据交换特性和磁盘的预读能力（空间局部性原理）。</li>
</ul>
</li>
</ul>
<h4 id="B树和B-树区别，B-树相比B树的优点？"><a href="#B树和B-树区别，B-树相比B树的优点？" class="headerlink" title="B树和B+树区别，B+树相比B树的优点？"></a>B树和B+树区别，B+树相比B树的优点？</h4><p><img src="D:\hexoBlog\source_posts\MySQL\09-2.png"></p>
<p>B树其实就是多路平衡二叉树，路 = 关键字 + 1，显然B树完美解决了上述平衡二叉树的问题，它的深度取决于每个节点关键字的个数，而且每个磁盘块放的关键字多了以后可以更好的利用磁盘的特性，减少IO的次数（所以在建表的时候，尽量选长度合适的数据类型，节省索引的空间）。B+树由B树和索引顺序访问方法（ISAM，这也是MyISAM引擎最初参考的数据结构）演化而来，但是在实现过程中几乎没有使用B树的情况了。</p>
<p><img src="D:\hexoBlog\source_posts\MySQL\09-3.png"></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> B+树相比B树特点<ul>
<li>B+树非叶子节点不保存数据相关的信息，只保存关键字和子节点的引用，关键字对应的数据保存在叶子节点中，叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系，通过指针进行链接，实际上是一个有序链表。    </li>
<li>B+树的关键字采用闭合区间，这也是它之所以能够实现除了叶子节点都不放数据的结构特性，例如下图[1，28)，假如找1，显然我们就一直往下找直到叶子节点，而如果在B树里，如果1是关键字，那在根节点就已经命中了；</li>
<li>B+树的关键字为什么采用左闭合区间而不是右闭？因为我们的使用中一般主键数据都是是自增的，所以往右边插入比较多，所以设计成左闭合区间；</li>
</ul>
</li>
<li><input checked="" disabled="" type="checkbox"> B+树作为索引树相比B树优点<ul>
<li>B+树是B树的变种（plus）多路绝对平衡查找树，它拥有B树的优势</li>
<li>B+树的扫库扫表的能力更强（只需要扫叶子节点，而且叶子节点是有序链表）</li>
<li>B+树的磁盘读写能力更强——高扇出性（非叶子节点不保存数据区，每个磁盘块可以保存更多的关键字）</li>
<li>B+树的排序能力更强（B+树天然具备排序功能，B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高）</li>
<li>B+树的查询效率更加稳定（IO的次数恒定，因为叶子节点的深度相同）</li>
</ul>
</li>
</ul>
<h3 id="MySQl中的索引体现形式——MyISAM-和-InnoDB"><a href="#MySQl中的索引体现形式——MyISAM-和-InnoDB" class="headerlink" title="MySQl中的索引体现形式——MyISAM 和 InnoDB"></a>MySQl中的索引体现形式——MyISAM 和 InnoDB</h3><p>MyISAM的表结构文件包括：</p>
<ul>
<li>.frm – 表结构定义</li>
<li>.MYI – 索引</li>
<li>.MYD – 数据</li>
</ul>
<p>InnoDB的表数据文件为：</p>
<ul>
<li>.frm – 表结构定义</li>
<li>.ibd – 数据（索引）</li>
</ul>
<h3 id="MyISAM中的索引"><a href="#MyISAM中的索引" class="headerlink" title="MyISAM中的索引"></a>MyISAM中的索引</h3><p>我们可以看出在MyISAM中数据和索引是分开存储的，虽然也是基于B+索引树，但其叶子节点中存储的是数据的地址，而且它的索引没有主次之分，都是平级的，如下图所示。与InnoDB存储引擎不同的是，因为没有聚集索引，其索引叶节点存放的键值不是主键值，而是在MYD文件中的物理位置</p>
<p><img src="D:\hexoBlog\source_posts\MySQL\09-4.png"></p>
<h3 id="InooDB中的索引（聚集索引和辅助索引）"><a href="#InooDB中的索引（聚集索引和辅助索引）" class="headerlink" title="InooDB中的索引（聚集索引和辅助索引）"></a>InooDB中的索引（聚集索引和辅助索引）</h3><p><img src="D:\hexoBlog\source_posts\MySQL\09-5.png"></p>
<p>而在InnoDB中数据和索引是存储在一起的，在InnoDB中，真正的数据存储在<strong>聚集索引</strong>（默认为主键索引）的叶子节点上，所以说它是也主键为索引来组织数据的存储的，而且除了聚集索引，其他索引（<strong>辅助索引</strong>）的叶子节点上存的是对应数据行主键的值，所以我们如果用辅助索引查找数据时会先从辅助索引找到对应行的主键，然后再用聚集索引去找到真正的数据，这个过程也称为<strong>回表</strong>。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚集索引。</p>
<blockquote>
<p>注意若辅助索引是一个包含主键的联合索引，那么并不需要一个额外的列来存放主键值。辅助索引会选择通过联合索引中的主键进行查找。换而言之，辅助索引（可能为联合索引）会默认包含主键。</p>
</blockquote>
<p>其他问题：</p>
<ol>
<li>聚集索引：数据库中行中数据的物理顺序与键值的逻辑（索引）顺序相同，很好理解，在表中我们按主键排序数据，那么主键索引中也是按主键组织数据，所以顺序相同。</li>
<li>为什么辅助索引不直接存储数据的地址？因为如果直接存储数据的地址的话，数据一旦更新发生地址的变化的话，除了维护主键索引外要维护所有的辅助索引，开销较大。而且因为主键索引最常用，辅助索引用的不多所以其查询慢一点可以忍受。</li>
<li>如果没有主键怎么办？这时默认以隐藏列 row_id 为聚集索引的关键值。</li>
</ol>
<h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h3 id="该不该建索引？"><a href="#该不该建索引？" class="headerlink" title="该不该建索引？"></a>该不该建索引？</h3><p>并不是所有在查询条件中出现的列都需要添加索引，胡乱的添加索引会让数据库变得非常臃肿甚至会降低查询的效率。对于什么时候添加B+树索引，一般的经验是，在访问表中很少一部分行时使用B+树索引才有意义。例如对于性别字段、地区字段，它们可取值的范围很小，称为低选择性，而对于ID字段其不会重复称为高选择性，定义一个参数<code>Cardinality</code>来衡量此列的选择性。数据库对于Cardinality的统计都是通过采样（sample）的方法来完成的。在InnoDB存储引擎中，Cardinality统计信息的更新发生在两个操作中：INSERT和UPDATE。根据前面的叙述，不可能在每次发生INSERT和UPDATE时都去更新Cardinality的信息，这会增加数据库系统的负荷，同时对大表进行统计时，时间上也不允许。因此InnoDB存储引擎对于更新Cardinality信息的策略为表中1/16的数据已发生变化，或者变化的次数大于定值（2000000000）。每次对于Cardinality值的统计都是通过随机读取8个叶子节点得到的，这又暗示了另一个Cardinality的现象，即每次得到的Cardinality值可能是不同的。可通过打印index信息查看索引列Cardinality的值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> index <span class="keyword">from</span> account \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">        <span class="keyword">Table</span>: account</span><br><span class="line">   Non_unique: <span class="number">0</span></span><br><span class="line">     Key_name: <span class="keyword">PRIMARY</span></span><br><span class="line"> Seq_in_index: <span class="number">1</span></span><br><span class="line">  Column_name: ID</span><br><span class="line">    <span class="keyword">Collation</span>: A</span><br><span class="line">  <span class="keyword">Cardinality</span>: <span class="number">3</span></span><br><span class="line">     Sub_part: <span class="keyword">NULL</span></span><br><span class="line">       Packed: <span class="keyword">NULL</span></span><br><span class="line">         <span class="keyword">Null</span>:</span><br><span class="line">   Index_type: BTREE</span><br><span class="line">      Comment:</span><br><span class="line">Index_comment:</span><br><span class="line">      Visible: YES</span><br><span class="line">   Expression: <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure>

<h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>联合索引是指对表上的多个列进行索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span> <span class="operator">|</span> <span class="keyword">Create</span> <span class="keyword">Table</span>                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `a` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `b` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`a`),</span><br><span class="line">  KEY `inx_a_b` (`a`,`b`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8mb4_0900_ai_ci <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+----------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p>例如上面的 inx_a_b 就是一个联合索引，其关键值的排序时先排前面的字段再依次排后面的字段，例如下图所示。显然联合索引的优点是帮助我们对组合的列进行快速的查询。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a<span class="operator">=</span>xxx <span class="keyword">and</span> b<span class="operator">=</span>xxx; <span class="comment">-- 可用联合索引</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a<span class="operator">=</span>xxx;           <span class="comment">-- 可用联合索引 </span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> b<span class="operator">=</span>xxx;           <span class="comment">-- 不可用联合索引</span></span><br></pre></td></tr></table></figure>
<p>显然是可以使用（a，b）这个联合索引的。对于单个的a列查询也可以使用这个联合索引（但当存在a列的单列索引时会优先使用单列索引，因为单个键值每页能存放的记录更多，用单列索引更快），但是对于b列的查询不可以使用这棵B+树索引，原因是显而易见的，因为其第二列只在第一列的值确定了后才是有序的，我们可以利用这个性质对第二个键值进行排序，例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> <span class="keyword">TABLE</span> <span class="keyword">WHERE</span> a<span class="operator">=</span>xxx <span class="keyword">ORDER</span> <span class="keyword">BY</span> b;           <span class="comment">-- 可用联合索引 </span></span><br></pre></td></tr></table></figure>
<p>总而言之就是一句话，<strong>联合索引要遵循最左前缀原则，带头大哥不能死，中间兄弟不能断</strong>。<br><img src="D:\hexoBlog\source_posts\MySQL\09-6.png"></p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>InnoDB存储引擎支持覆盖索引（covering index），或称索引覆盖（index coverage），即从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录。使用覆盖索引的好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作。用通俗的话解释一下，假如我们的表格t一共有5列a-e，其中主键为a，我们知道完整的记录是存放在聚集索引中的，现在我们新建了一个 inx_b_c(b,c)，显然这个辅助索引里只保存a,b,c三列（默认包含主键）的数据，假如我只要这三列的数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> t <span class="keyword">where</span> b<span class="operator">=</span>x <span class="keyword">and</span> c<span class="operator">=</span>x;</span><br><span class="line"><span class="keyword">select</span> b <span class="keyword">from</span> t <span class="keyword">where</span> a<span class="operator">=</span>x <span class="keyword">and</span> c<span class="operator">=</span>x;</span><br><span class="line"><span class="keyword">select</span> c <span class="keyword">from</span> t <span class="keyword">where</span> a<span class="operator">=</span>x <span class="keyword">and</span> b<span class="operator">=</span>x;</span><br><span class="line"><span class="keyword">select</span> a,b <span class="keyword">from</span> t <span class="keyword">where</span> c<span class="operator">=</span>x;</span><br><span class="line"><span class="keyword">select</span> a,c <span class="keyword">from</span> t <span class="keyword">where</span> b<span class="operator">=</span>x;</span><br><span class="line"><span class="keyword">select</span> b,c <span class="keyword">from</span> t <span class="keyword">where</span> a<span class="operator">=</span>x;</span><br></pre></td></tr></table></figure>
<p>那么此时就可以只用 inx_b_c 就可以了，并不需要再回表去聚集索引里查询。覆盖索引的另一个好处是对于某些统计问题，辅助索引小于聚集索引，可以减少IO操作，因为每个列的行数都是一样的。例如我们用上表只查询b列，可以看到 possible_keys 为空但却使用到了索引，并且显示 Using index ，说明使用到了辅助索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> explain <span class="keyword">select</span> b <span class="keyword">from</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span> <span class="operator">|</span> partitions <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> filtered <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> t     <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> index <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> inx_a_b <span class="operator">|</span> <span class="number">9</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>   <span class="number">100.00</span> <span class="operator">|</span> <span class="keyword">Using</span> index <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="INDEX-HINT（索引提示）"><a href="#INDEX-HINT（索引提示）" class="headerlink" title="INDEX HINT（索引提示）"></a>INDEX HINT（索引提示）</h3><p>MySQL数据库支持INDEX HINT（索引提示），显式地告诉优化器使用哪个索引。使用方法有以下两种：</p>
<ul>
<li>建议：USE INDEX() 只是告诉优化器可以选择该索引，而实际上优化器还是会根据自己的判断进行选择。</li>
<li>强制：FORCE INDEX() 是强制优化器必须使用该索引。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t USE INDEX(a) <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t FORCE INDEX(a) <span class="keyword">WHERE</span> a<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> b<span class="operator">=</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Multi-Range-Read-MMR"><a href="#Multi-Range-Read-MMR" class="headerlink" title="Multi-Range Read(MMR)"></a>Multi-Range Read(MMR)</h3><p>MRR优化的目的就是减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，可为IO-bound类型的SQL查询语句带来性能的极大提升。MRR优化适用于range、ref和eq_ref类型的查询。MRR优化有以下几个好处：</p>
<ul>
<li>使得数据访问变得较为顺序。在查询辅助索引时，先对得到的查询结果按照主键进行排序，并按照主键排列的顺序进行书签查找（回表）。</li>
<li>减少缓冲池中页被替换的次数。</li>
<li>批量处理对键值的查询操作。</li>
</ul>
<p>对于InnoDB和MyISAM存储引擎的范围查询和联接查询，MRR的工作方式如下：</p>
<ul>
<li>将查询得到的辅助索引键值存放于一个<strong>缓存</strong>中，这时缓存中的数据是根据辅助索引键值排序的。</li>
<li>将缓存中的键值根据 RowID 进行排序。</li>
<li>根据 RowID 的排序顺序来访问实际的数据文件。</li>
</ul>
<h3 id="Index-Condition-Pushdown-ICP"><a href="#Index-Condition-Pushdown-ICP" class="headerlink" title="Index Condition Pushdown(ICP)"></a>Index Condition Pushdown(ICP)</h3><p>和MRR一样，Index Condition Pushdown（ICP）同样是MySQL5.6开始支持的一种根据索引进行查询的优化方式。之前的MySQL版本不支持ICP，当进行索引查询时，首先根据索引来查找记录，然后再根据WHERE条件来过滤记录。在支持ICP后，MySQL数据库会在取出索引的同时，判断是否可以进行WHERE条件的过滤，<strong>即将WHERE的部分过滤操作放在了存储引擎层，当然，WHERE可以过滤的条件是该索引可以覆盖到的范围</strong>。ICP优化支持range、ref、eq_ref和ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。当优化器选择ICP优化时，可在执行计划的Extra列看到<code>Usingindex condition</code>提示。</p>
<h3 id="打油诗（口诀）"><a href="#打油诗（口诀）" class="headerlink" title="打油诗（口诀）"></a>打油诗（口诀）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">全值匹配我最爱， 最左前缀要遵守； </span><br><span class="line">带头大哥不能死， 中间兄弟不能断； </span><br><span class="line">索引列上少计算， 范围之后全失效； </span><br><span class="line">LIKE百分写最右， 覆盖索引不写 *； </span><br><span class="line">不等空值还有OR， 索引影响要注意； </span><br><span class="line">VAR 引号不可丢， SQL 优化有诀窍。</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/InnoDB/" rel="tag"><i class="fa fa-tag"></i> InnoDB</a>
              <a href="/tags/%E7%B4%A2%E5%BC%95/" rel="tag"><i class="fa fa-tag"></i> 索引</a>
              <a href="/tags/B-%E6%A0%91/" rel="tag"><i class="fa fa-tag"></i> B+树</a>
              <a href="/tags/%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/" rel="tag"><i class="fa fa-tag"></i> 索引优化</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/03/18/MySQL08_MySQL%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/" rel="prev" title="MySQL中的事务处理">
                  <i class="fa fa-chevron-left"></i> MySQL中的事务处理
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/04/02/MySQL10_MySQL%E4%B8%AD%E7%9A%84%E5%88%86%E5%8C%BA/" rel="next" title="MySQL中的分区">
                  MySQL中的分区 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saltedfish</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">555k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:48</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
