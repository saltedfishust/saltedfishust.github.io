<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta name="description" content="优先队列 堆有序定义：当一颗二叉树的每个节点都大于等于（或小于等于）它的两个子节点时，它被称为堆有序。 堆有序原理：根节点是堆有序的二叉树的最大节点（最小节点）。 二叉堆表示法：堆有序的二叉树使用完全二叉树来表示，由于使用了完全二叉树，使得我们可以用数组来存储二叉堆，而数组的索引代表节点的位置，即按照层级顺序放入数组，根节点在索引1(第一个位置不使用)，两个子节点在索引2,3… 二叉堆定义：二叉堆">
<meta property="og:type" content="article">
<meta property="og:title" content="排序之优先队列与堆排序">
<meta property="og:url" content="http://example.com/2019/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="Saltedfish">
<meta property="og:description" content="优先队列 堆有序定义：当一颗二叉树的每个节点都大于等于（或小于等于）它的两个子节点时，它被称为堆有序。 堆有序原理：根节点是堆有序的二叉树的最大节点（最小节点）。 二叉堆表示法：堆有序的二叉树使用完全二叉树来表示，由于使用了完全二叉树，使得我们可以用数组来存储二叉堆，而数组的索引代表节点的位置，即按照层级顺序放入数组，根节点在索引1(第一个位置不使用)，两个子节点在索引2,3… 二叉堆定义：二叉堆">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-20T11:25:15.000Z">
<meta property="article:modified_time" content="2021-01-25T15:11:08.000Z">
<meta property="article:author" content="Saltedfish">
<meta property="article:tag" content="优先队列与堆排序">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2019/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<title>排序之优先队列与堆排序 | Saltedfish</title><script data-pjax src="/js/load-config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Saltedfish</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of saltedfish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">156</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">9</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">85</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">优先队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="nav-number">2.</span> <span class="nav-text">索引优先队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-number">3.</span> <span class="nav-text">堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E9%98%B6%E6%AE%B5-%E2%80%93-sink-%E6%AF%94-swim-%E6%9B%B4%E9%AB%98%E6%95%88"><span class="nav-number">3.0.0.0.1.</span> <span class="nav-text">构造阶段 – sink 比 swim 更高效</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8E%92%E5%BA%8F%E9%98%B6%E6%AE%B5"><span class="nav-number">3.0.0.0.2.</span> <span class="nav-text">排序阶段</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.0.0.0.3.</span> <span class="nav-text">复杂度</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Saltedfish"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Saltedfish</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">85</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">156</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/07/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E4%B9%8B%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Saltedfish">
      <meta itemprop="description" content="Stay hungry, stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saltedfish">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          排序之优先队列与堆排序
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-20 19:25:15" itemprop="dateCreated datePublished" datetime="2019-07-20T19:25:15+08:00">2019-07-20</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-25 23:11:08" itemprop="dateModified" datetime="2021-01-25T23:11:08+08:00">2021-01-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>18 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><ul>
<li>堆有序定义：当一颗二叉树的每个节点都大于等于（或小于等于）它的两个子节点时，它被称为堆有序。</li>
<li>堆有序原理：根节点是堆有序的二叉树的最大节点（最小节点）。</li>
<li>二叉堆表示法：堆有序的二叉树使用完全二叉树来表示，由于使用了完全二叉树，使得我们可以用数组来存储二叉堆，而数组的索引代表节点的位置，即按照层级顺序放入数组，根节点在索引1(第一个位置不使用)，两个子节点在索引2,3…</li>
<li>二叉堆定义：二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级存储（不使用数组中的第一个元素）。</li>
<li>优先队列：基于数据结构——二叉堆（简称为堆）实现。</li>
<li>定理：一颗具有N个节点的完全二叉树的高度为<code>$\lfloor lgN \rfloor$</code>（规定：只有根节点的树高度为0）。</li>
<li>复杂度：对于一个含有N个元素的基于堆的优先队列，插入元素操作只需不超过（lgN+1）次比较，删除最大（最小）元素的操作不超过2lgN次比较。<span id="more"></span></li>
</ul>
<p><code>Show me the code</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以动态扩容的优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] pQueue; <span class="comment">// 基于堆的完全二叉树，后面实现了数组的动态扩容，使数组的内存空间既不浪费又不至于紧张</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;  <span class="comment">// N为当前索引值-1，存储于pQueue[1,N]之中，pQueue[0]没有使用，也代表数组中现存的元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxN;   <span class="comment">// maxN为给定数组的有效长度（数组实际长度-1）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxN = n;</span><br><span class="line">        pQueue = (T[]) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>]; <span class="comment">// 不允许创建泛型数组，必须要转型</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> usedLength = N+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (usedLength &gt;= maxN*<span class="number">3</span>/<span class="number">4</span>) <span class="comment">// 大于数组长度的3/4，扩容成两倍</span></span><br><span class="line">            resize(maxN*<span class="number">2</span>);</span><br><span class="line">        pQueue[++N] = value; <span class="comment">// 执行插入操作；同时更新N，注意这里不能用N++</span></span><br><span class="line">        swim(N); <span class="comment">// 从堆底加入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pQueue[<span class="number">1</span>] == <span class="keyword">null</span>) <span class="comment">// 已为空，不执行任何操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        T max = pQueue[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>,N--);      <span class="comment">// 把最后一个元素放在顶端，然后N--(堆的大小-1)</span></span><br><span class="line">        sink(<span class="number">1</span>);         <span class="comment">// 让“最后”一个元素下沉</span></span><br><span class="line">        pQueue[N+<span class="number">1</span>] = <span class="keyword">null</span>; <span class="comment">// 将垃圾（删除的最大值）清空</span></span><br><span class="line">        <span class="keyword">if</span> (N &lt;= maxN/<span class="number">4</span>)   <span class="comment">// 小于数组长度的1/4，缩容成原来的一半</span></span><br><span class="line">            resize(maxN/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩容 或者 缩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newLength)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxN = newLength;</span><br><span class="line">        T[] newPQueue = (T[]) <span class="keyword">new</span> Comparable[maxN+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">// 注意这里是 1-N</span></span><br><span class="line">            newPQueue[i] = pQueue[i];</span><br><span class="line">        pQueue = newPQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的比较方法：返回pQueue[i]是否小于pQueue[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pQueue[i].compareTo(pQueue[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的交换方法：交换pQueue[i] 和 pQueue[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T temp = pQueue[i];</span><br><span class="line">        pQueue[i] = pQueue[j];</span><br><span class="line">        pQueue[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮：当某个节点变大（或在堆底加入了一个新的元素），主要用于插入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k)) &#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k); <span class="comment">// k/2默认向下取整</span></span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉：当某个节点变小（例如，将根节点替换为一个较小的元素），主要用于删除最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>)) <span class="comment">// 找到较大的子节点，并将j指向它</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,j)) <span class="comment">// 此时j一定指向较大的子节点，如果pQueue[k] &gt;= pQueue[j],则下沉结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j); <span class="comment">// 如果没有break则说明pQueue[k] &lt; pQueue[j],交换pQueue[k]、pQueue[j]</span></span><br><span class="line">            k = j;     <span class="comment">// 交换k、j，让k始终指向下沉的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;PriorityQueue &quot;</span> +</span><br><span class="line">                Arrays.toString(pQueue) +</span><br><span class="line">                <span class="string">&quot;, UsedSize=&quot;</span> + N +</span><br><span class="line">                <span class="string">&quot;, ArraySize=&quot;</span> + maxN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test 扩容</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            priorityQueue.insert(i);</span><br><span class="line">        System.out.println(priorityQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test 缩容</span></span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        priorityQueue.delMax();</span><br><span class="line">        System.out.println(priorityQueue);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 9, 8, 5, 6, 7, 1, 4, 0, 3, 2, null, null, null, null, null, null, null, null, null, null], UsedSize=10, ArraySize=20</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 3, 2, 1, 0, null, null, null, null, null, null], UsedSize=4, ArraySize=10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="索引优先队列"><a href="#索引优先队列" class="headerlink" title="索引优先队列"></a>索引优先队列</h2><p>讲解参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/nullzx/p/6624731.html">https://www.cnblogs.com/nullzx/p/6624731.html</a></p>
<p><code>Show me the code</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引优先队列：优先队列只能操作队头和队尾的元素，而索引优先队列可以更新队列中任意位置的值，实现原理就是通过两个索引，一个正向索引，一个反向索引。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexPriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*示例：按照字母排序</span></span><br><span class="line"><span class="comment">     Index     0       1     2        3     4     5        6     7        8     9        10    11</span></span><br><span class="line"><span class="comment">    indexPq    null    10    3        6     1     4        8     null     null  null     null  null</span></span><br><span class="line"><span class="comment">    reIndexQp  null    4     null     2     5     null     3     null     6     null     1     null</span></span><br><span class="line"><span class="comment">    elements   null    k     null     f     n     null     c     null     h     null     b     null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 存储有优先级之分的元素（对象引用），不一定连续存放</span></span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line">    <span class="comment">// 索引二叉堆，从索引1开始按优先级（大小顺序）存储elements元素的下标，连续存放，即indexPq里存储的下标所对应的elements数组的元素才是真正有序的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indexPq;</span><br><span class="line">    <span class="comment">// 反向索引：reIndexQp[indexPq[i]] = indexPq[reIndexQp[i]] = i，</span></span><br><span class="line">    <span class="comment">// 作用是存储元素在elements数组中的索引值在index数组中的下标，这个数组也不是连续存放的，和elements数组对齐</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] reIndexQp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;       <span class="comment">// elements数组中现存的元素个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexPriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        elements = (T[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>]; <span class="comment">// 不允许创建泛型数组，必须要转型</span></span><br><span class="line">        indexPq = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        reIndexQp = <span class="keyword">new</span> <span class="keyword">int</span>[maxN +<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxN; i++)</span><br><span class="line">            reIndexQp[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reIndexQp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入:在k位置插入元素，位置k并不代表任何含义，只是存储在elements数组的索引位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, T value)</span> </span>&#123;</span><br><span class="line">        N++;</span><br><span class="line">        elements[k] = value; <span class="comment">// 放入索引k</span></span><br><span class="line">        indexPq[N] = k;      <span class="comment">// 记录此元素所在索引位置（k）</span></span><br><span class="line">        reIndexQp[k] = N;    <span class="comment">// 记录indexPq数组中哪个位置（N）存储着此元素的索引</span></span><br><span class="line">        swim(N);             <span class="comment">// 从堆底加入并上浮，维护indexPq 和 reIndexQp</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">max</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[indexPq[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexPq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最大值，并返回其索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexOfMax = indexPq[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (elements[indexOfMax] == <span class="keyword">null</span>) <span class="comment">// 已为空，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        exch(<span class="number">1</span>,N--);                 <span class="comment">// 把最后一个元素（最小元素）放在顶端，然后N--(堆的大小-1)</span></span><br><span class="line">        sink(<span class="number">1</span>);                    <span class="comment">// 让“最后”一个元素下沉</span></span><br><span class="line">        elements[indexPq[N+<span class="number">1</span>]] = <span class="keyword">null</span>; <span class="comment">// 将垃圾（删除的最大值）清空</span></span><br><span class="line">        reIndexQp[indexPq[N+<span class="number">1</span>]] = -<span class="number">1</span>;  <span class="comment">// 更新对应reIndexQp为-1</span></span><br><span class="line">        indexPq[N+<span class="number">1</span>] = <span class="number">0</span>;              <span class="comment">// 更新最后一位删除的indexPq为0</span></span><br><span class="line">        <span class="keyword">return</span> indexOfMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引k位置的元素，与删除最大值类似</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexOfPq = reIndexQp[k];</span><br><span class="line">        exch(indexOfPq,N--);</span><br><span class="line">        swim(indexOfPq);</span><br><span class="line">        sink(indexOfPq);</span><br><span class="line">        elements[k] = <span class="keyword">null</span>;</span><br><span class="line">        reIndexQp[k] = -<span class="number">1</span>;</span><br><span class="line">        indexPq[N+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, T newValue)</span> </span>&#123;</span><br><span class="line">        elements[k] = newValue;</span><br><span class="line">        <span class="comment">// 更新值后，可能出现三种情况：</span></span><br><span class="line">        <span class="comment">//    1. 比父节点大：需要上浮</span></span><br><span class="line">        <span class="comment">//    2. 比子节点小：需要下沉</span></span><br><span class="line">        <span class="comment">//    3. 大小在父节点和子节点之间：不执行任何操作</span></span><br><span class="line">        <span class="comment">// 所以此处采取的策略是先上浮在下沉（或先下沉再上浮）</span></span><br><span class="line">        swim(reIndexQp[k]); <span class="comment">// 上浮</span></span><br><span class="line">        sink(reIndexQp[k]); <span class="comment">// 下沉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的比较方法：这里怎么设计关乎着是大堆顶(&lt;0)还是小堆顶(&gt;0)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[indexPq[i]].compareTo(elements[indexPq[j]]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的交换方法：交换indexPq[i]、indexPq[j] 和 reIndexPq[i]、reIndexPq[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempPq = indexPq[i];</span><br><span class="line">        indexPq[i] = indexPq[j];</span><br><span class="line">        indexPq[j] = tempPq;</span><br><span class="line">        reIndexQp[indexPq[i]] = i;</span><br><span class="line">        reIndexQp[indexPq[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮：当某个节点变大（或在堆底加入了一个新的元素），主要用于插入</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; less(k/<span class="number">2</span>,k)) &#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k); <span class="comment">// k/2默认向下取整</span></span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉：当某个节点变小（例如，将根节点替换为一个较小的元素），主要用于删除最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j,j+<span class="number">1</span>)) <span class="comment">// 找到较大的子节点，并将j指向它</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(k,j)) <span class="comment">// 此时j一定指向较大的子节点，如果elements[indexPq[k]] &gt;= elements[indexPq[j]],则下沉结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j); <span class="comment">// 如果没有break则说明elements[indexPq[k]] &lt; elements[indexPq[j]]，交换indexPq 和 reIndexQp</span></span><br><span class="line">            k = j;     <span class="comment">// 交换k、j，让k始终指向下沉的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;      indexPq &quot;</span> +</span><br><span class="line">                Arrays.toString(indexPq) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    reIndexQp &quot;</span> +</span><br><span class="line">                Arrays.toString(reIndexQp) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;PriorityQueue &quot;</span> +</span><br><span class="line">                Arrays.toString(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestPriorityQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IndexPriorityQueue&lt;Integer&gt; indexPq = <span class="keyword">new</span> IndexPriorityQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line">        indexPq.insert(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        indexPq.insert(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">        indexPq.insert(<span class="number">4</span>,<span class="number">4</span>);</span><br><span class="line">        indexPq.insert(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line">        indexPq.insert(<span class="number">8</span>,<span class="number">8</span>);</span><br><span class="line">        indexPq.insert(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(indexPq);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(indexPq.max() + <span class="string">&quot; &quot;</span> + indexPq.maxIndex());</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        indexPq.delMax();</span><br><span class="line">        System.out.println(indexPq);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        indexPq.change(<span class="number">3</span>,<span class="number">11</span>);</span><br><span class="line">        System.out.println(indexPq);</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        indexPq.delete(<span class="number">3</span>);</span><br><span class="line">        System.out.println(indexPq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">      indexPq [0, 10, 6, 8, 1, 4, 3, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">    reIndexQp [-1, 4, -1, 6, 5, -1, 2, -1, 3, -1, 1]</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 1, null, 3, 4, null, 6, null, 8, null, 10]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">10 10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      indexPq [0, 8, 6, 3, 1, 4, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">    reIndexQp [-1, 4, -1, 3, 5, -1, 2, -1, 1, -1, -1]</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 1, null, 3, 4, null, 6, null, 8, null, null]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      indexPq [0, 3, 6, 8, 1, 4, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">    reIndexQp [-1, 4, -1, 1, 5, -1, 2, -1, 3, -1, -1]</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 1, null, 11, 4, null, 6, null, 8, null, null]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      indexPq [0, 8, 6, 4, 1, 0, 0, 0, 0, 0, 0]</span></span><br><span class="line"><span class="comment">    reIndexQp [-1, 4, -1, -1, 3, -1, 2, -1, 1, -1, -1]</span></span><br><span class="line"><span class="comment">PriorityQueue [null, 1, null, null, 4, null, 6, null, 8, null, null]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>有了前面的基础，堆排序就非常简单了，思路就是先构造一个大顶堆，每次交换堆顶（数组头）和数组“最后”一个元素（最后一个元素的索引不断前移），然后让交换到堆顶的一个元素下沉，保持堆的有序性，最终输出从小到大排列有序的数组。</p>
<h6 id="构造阶段-–-sink-比-swim-更高效"><a href="#构造阶段-–-sink-比-swim-更高效" class="headerlink" title="构造阶段 – sink 比 swim 更高效"></a>构造阶段 – sink 比 swim 更高效</h6><p>高效的堆构造：因为数组的每个位置都已经是一个子堆的根节点了，所以以数组前半部分为根节点的子树一定包含了所有的元素，我们可以<strong>从N/2处自右至左扫描</strong>，即只扫描数组前半部分，然后<code>sink()</code>，只需少于2N次比较以及少于N次交换就可以构造出有序的堆。</p>
<h6 id="排序阶段"><a href="#排序阶段" class="headerlink" title="排序阶段"></a>排序阶段</h6><p>数组从左到右不断将最大元素放到最后，然后让”最后”一个元素下沉，保持堆的有序性，最终输出从小到大排列有序的数组</p>
<h6 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h6><p>将N个元素排序，堆排序只需少于（2NlgN+2N）次比较以及一半次数的交换。其中2NlgN来自下沉阶段，2N来自构造阶段。</p>
<p><code>Show me the code</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Comparable[] toBeSortedArray; <span class="comment">// 待排序的数组</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeapSort</span><span class="params">(Comparable[] toBeSortedArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.toBeSortedArray = toBeSortedArray;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = toBeSortedArray.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆构造阶段：使用sink操作，从N/2处自右至左扫描，只需少于N次比较以及少于N次交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = N/<span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(k, N);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 堆排序阶段：数组从左到右不断将最大元素放到最后，然后让最后一个元素下沉，保持堆的有序性，最终输出从小到大排列有序的数组</span></span><br><span class="line">        <span class="keyword">int</span> n = N;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            exch(<span class="number">1</span>, n--);</span><br><span class="line">            sink(<span class="number">1</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j+<span class="number">1</span>))</span><br><span class="line">                j++;  <span class="comment">// 找到两个子节点中较大的那个</span></span><br><span class="line">            <span class="keyword">if</span> (!less(k, j)) <span class="comment">// 这时j一定指向较大的子节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            exch(k, j); <span class="comment">// 如果没有break则说明pq[k-1] &lt; pq[j-1],交换pq[k-1]、pq[j-1]</span></span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：因为数组是从索引0开始存储的，而堆排序的索引为了计算方便从1开始，所以要 -1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> toBeSortedArray[i-<span class="number">1</span>].compareTo(toBeSortedArray[j-<span class="number">1</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        Comparable swap = toBeSortedArray[i-<span class="number">1</span>];</span><br><span class="line">        toBeSortedArray[i-<span class="number">1</span>] = toBeSortedArray[j-<span class="number">1</span>];</span><br><span class="line">        toBeSortedArray[j-<span class="number">1</span>] = swap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断数组是否有序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSorted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; toBeSortedArray.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (!less(i,i+<span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer[] testArray = &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">0</span>&#125;; <span class="comment">// 注意数组是从索引0开始存储的，而堆排序的索引为了计算方便从1开始</span></span><br><span class="line">        HeapSort heapSort = <span class="keyword">new</span> HeapSort(testArray);</span><br><span class="line">        heapSort.sort();</span><br><span class="line">        System.out.println(heapSort.isSorted());</span><br><span class="line">        System.out.println(Arrays.toString(testArray));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">    true</span></span><br><span class="line"><span class="comment">    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F/" rel="tag"><i class="fa fa-tag"></i> 优先队列与堆排序</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/07/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/" rel="prev" title="排序之快速排序">
                  <i class="fa fa-chevron-left"></i> 排序之快速排序
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/07/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%BB%E7%BB%93/" rel="next" title="各种排序算法的总结">
                  各种排序算法的总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saltedfish</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">555k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:48</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
