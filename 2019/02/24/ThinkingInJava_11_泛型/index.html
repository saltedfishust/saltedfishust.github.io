<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta name="description" content="何为泛型泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="类型信息">
<meta property="og:url" content="http://example.com/2019/02/24/ThinkingInJava_11_%E6%B3%9B%E5%9E%8B/index.html">
<meta property="og:site_name" content="Saltedfish">
<meta property="og:description" content="何为泛型泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-02-23T18:17:00.000Z">
<meta property="article:modified_time" content="2021-01-25T07:42:48.000Z">
<meta property="article:author" content="Saltedfish">
<meta property="article:tag" content="泛型">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2019/02/24/ThinkingInJava_11_%E6%B3%9B%E5%9E%8B/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<title>类型信息 | Saltedfish</title><script data-pjax src="/js/load-config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Saltedfish</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of saltedfish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">113</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">55</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BD%95%E4%B8%BA%E6%B3%9B%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">何为泛型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">泛型方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E5%92%8C%E8%BE%B9%E7%95%8C"><span class="nav-number">5.</span> <span class="nav-text">通配符和边界</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E5%AE%9A%E9%80%9A%E9%85%8D%E7%AC%A6-lt-gt"><span class="nav-number">5.1.</span> <span class="nav-text">无限定通配符 &lt;?&gt;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E4%B8%8A%E9%99%90%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6-lt-extends-T-gt"><span class="nav-number">5.2.</span> <span class="nav-text">有上限的通配符 &lt;? extends T&gt;</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Saltedfish"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Saltedfish</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">113</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/02/24/ThinkingInJava_11_%E6%B3%9B%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Saltedfish">
      <meta itemprop="description" content="Stay hungry, stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saltedfish">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          类型信息
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-02-24 02:17:00" itemprop="dateCreated datePublished" datetime="2019-02-24T02:17:00+08:00">2019-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-25 15:42:48" itemprop="dateModified" datetime="2021-01-25T15:42:48+08:00">2021-01-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Thinking-in-java/" itemprop="url" rel="index"><span itemprop="name">Thinking in java</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>17k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>30 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="何为泛型"><a href="#何为泛型" class="headerlink" title="何为泛型"></a>何为泛型</h1><p>泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<span id="more"></span>

<p>一些常用的泛型类型变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E：元素（Element），多用于集合</span><br><span class="line">K：关键字（Key）</span><br><span class="line">V：值（Value）</span><br><span class="line">N：数字（Number）</span><br><span class="line">T：类型（Type）</span><br></pre></td></tr></table></figure>

<h1 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h1><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassA&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h1><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别的，泛型同时继承类和实现接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;T extends Class1 &amp; Interface1&gt; <span class="comment">// 具体的类在前面，接口在后</span></span><br><span class="line">&lt;T extends Class1 &amp; Interface1 &amp; Interface2&gt; <span class="comment">// 具体的类只能有一个，接口可以有多个</span></span><br></pre></td></tr></table></figure>

<h1 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h1><p><strong>泛型类，是在创建对象的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。</strong></p>
<p>泛型方法使得该方法能够独立于类而产生变化。以下是一个基本的指导原则：无论何时只要你能做到，你就应该尽量使用泛型方法。也就是说，如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚明白。另外，对于一个static的方法而言，无法访问泛型类的类型参数（因为static方法是与对象无关的），所以，如果static方法需要使用泛型能力，就必须使其成为泛型方法。</p>
<p>要定义泛型方法，只需将泛型参数列表置于返回值之前，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E09_GenericMethods</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现类似于无限重载的功能</span></span><br><span class="line">    <span class="keyword">public</span> &lt;A,B,C&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b, C c)</span> </span>&#123;</span><br><span class="line">        System.out.println(a.getClass().getName());</span><br><span class="line">        System.out.println(b.getClass().getName());</span><br><span class="line">        System.out.println(c.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        E09_GenericMethods gm = <span class="keyword">new</span> E09_GenericMethods();</span><br><span class="line">        gm.f(<span class="string">&quot;&quot;</span>, <span class="number">1</span>, <span class="number">1.0</span>);</span><br><span class="line">        gm.f(<span class="number">1.0F</span>, <span class="string">&#x27;c&#x27;</span>, gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">java.lang.String</span></span><br><span class="line"><span class="comment">java.lang.Integer</span></span><br><span class="line"><span class="comment">java.lang.Double</span></span><br><span class="line"><span class="comment">java.lang.Float</span></span><br><span class="line"><span class="comment">java.lang.Character</span></span><br><span class="line"><span class="comment">generics.E09_GenericMethods2</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<p>static示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 泛型方法里的T不是泛型类里的T，此处的T是一个局部变量，可以与类重名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，泛型方法与可变参数列表能够很好地共存：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericVarargs</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">makeList</span><span class="params">(T... args)</span> </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">        <span class="keyword">for</span>(T item : args)</span><br><span class="line">            result.add(item);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; ls = makeList(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">        ls = makeList(<span class="string">&quot;ABCDEFFHIJKLMNOPQRSTUVWXYZ&quot;</span>.split(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        System.out.println(ls);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[A]</span></span><br><span class="line"><span class="comment">[A, B, C]</span></span><br><span class="line"><span class="comment">[A, B, C, D, E, F, F, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

<h1 id="通配符和边界"><a href="#通配符和边界" class="headerlink" title="通配符和边界"></a>通配符和边界</h1><p>除了用 <T>表示泛型外，还有<code>&lt;?&gt;</code>这种形式。<code>？</code>被称为通配符。可能有同学会想，已经有了 <T>的形式了，为什么还要引进 &lt;?&gt;这样的概念呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Sub sub = <span class="keyword">new</span> Sub();</span><br><span class="line">Base base = sub;			</span><br></pre></td></tr></table></figure>
<p>上面代码显示，Base 是 Sub 的父类，它们之间是继承关系，所以 Sub 的实例可以给一个 Base 引用赋值，那么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Sub&gt; lsub = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//! List&lt;Base&gt; lbase = lsub; //编译错误</span></span><br></pre></td></tr></table></figure>
<p>最后一行代码成立吗？编译会通过吗？答案是否定的。编译器不会让它通过的。Sub 是 Base 的子类，不代表<code>List&lt;sub&gt;</code>和<code>List&lt;Base&gt;</code>有继承关系。但是，在现实编码中，确实有这样的需求，希望泛型能够处理某一范围内的数据类型，比如某个类和它的子类，对此Java引入了通配符这个概念。所以，通配符的出现是为了指定泛型中的类型范围。</p>
<p>通配符有 3 种形式。无论是T还是？，我们都应该记住，它都是一个实参，而不是一类参数或者形参，记住这一点有助于我们理解后面的知识。</p>
<ul>
<li><?>被称作无限定的通配符；</li>
<li><? extends T>被称作有上限的通配符；</li>
<li><? super T>被称作有下限的通配符。</li>
</ul>
<h2 id="无限定通配符-lt-gt"><a href="#无限定通配符-lt-gt" class="headerlink" title="无限定通配符 &lt;?&gt;"></a>无限定通配符 &lt;?&gt;</h2><p>无限定通配符经常与容器类配合使用，它其中的 ? 其实代表的是未知类型，所以涉及到 ? 时的操作，一定与具体类型无关。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestWildCards</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testWildCards</span><span class="params">(Collection&lt;?&gt; collection)</span></span>&#123;</span><br><span class="line">        <span class="comment">//! collection.add(123);    // 编译错误</span></span><br><span class="line">        <span class="comment">//! collection.add(&quot;hello&quot;);// 编译错误</span></span><br><span class="line">        </span><br><span class="line">        collection.iterator().next();</span><br><span class="line">        collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，方法内的参数是被无限定通配符修饰的 Collection 对象，它隐略地表达了一个意图或者可以说是限定，那就是 testWidlCards() 这个方法内部无需关注 Collection 中的真实类型，因为它是未知的。所以，你只能调用 Collection 中与类型无关的方法。我们可以看到，当 &lt;?&gt;存在时，Collection 对象丧失了 add( ) 方法的功能，编译器不通过。</p>
<ul>
<li>典型应用：捕获转换</li>
</ul>
<p>编译器并非总是关注像List和List<?>之间的这种差异，因此它们看起来就像是相同的事物。因为，事实上，由于泛型参数将擦除到它的第一个边界，因此List<?>看起来等价于List<Object>，<strong>而List实际上也是List<Object>。List实际上表示“持有任何 Object类型的原生List”，而List&lt;?&gt;表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么。</strong>”</p>
<p>有一种情况特别需要使用<?>而不是原生类型。如果向一个使用<?>的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在@ Suppress Warnings注解被移除之后才能起作用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Holder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Holder</span><span class="params">(T val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T val)</span> </span>&#123; value = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureConversion</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Holder&lt;T&gt; holder)</span> </span>&#123;</span><br><span class="line">        T t = holder.get();</span><br><span class="line">        System.out.println(t.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(Holder&lt;?&gt; holder)</span> </span>&#123;</span><br><span class="line">        f1(holder); <span class="comment">// Call with captured type</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Holder raw = <span class="keyword">new</span> Holder&lt;Integer&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// f1(raw); // Produces warnings</span></span><br><span class="line">        f2(raw);    <span class="comment">// No warnings</span></span><br><span class="line">        Holder rawBasic = <span class="keyword">new</span> Holder();</span><br><span class="line">        rawBasic.set(<span class="keyword">new</span> Object()); <span class="comment">// Warning</span></span><br><span class="line">        f2(rawBasic);               <span class="comment">// No warnings</span></span><br><span class="line">        <span class="comment">// Upcast to Holder&lt;?&gt;, still figures it out:</span></span><br><span class="line">        Holder&lt;?&gt; wildcarded = <span class="keyword">new</span> Holder&lt;Double&gt;(<span class="number">1.0</span>);</span><br><span class="line">        f2(wildcarded);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Object</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<p>f1()中的类型参数都是确切的，没有通配符或边界。在f2()中， Holder参数是一个无界通配符，因此它看起来是未知的。但是，在f2()中，f1()被调用，而f1()需要一个已知参数。这里所发生的是：参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用。注意，不能从f2()中返回T，因为T对于f2()来说是未知的。捕获转换十分有趣，但是非常受限。</p>
<h2 id="有上限的通配符-lt-extends-T-gt"><a href="#有上限的通配符-lt-extends-T-gt" class="headerlink" title="有上限的通配符 &lt;? extends T&gt;"></a>有上限的通配符 &lt;? extends T&gt;</h2><blockquote>
<p>这一部分如果实在理解不了就先去看下面的类型擦除再来看这里</p>
<p>例如List&lt;? extends T&gt; 中“? extends T”代表某个参数，不知道这个参数是什么，只知道它继承于T，注意是一个参数，不是代表的一类参数，把“? extends T”看作Person或者Teacher这种具体的一个参数；所以此时添加T或者任何T的子类都不安全，因为你不知道它是中间的哪一个；又因为List&lt;? extends T&gt;擦除为List<T>，所以超类也不能存进去，但是擦除为T类型，所以可以读出T类型的信息。</p>
<p>同理List&lt;? super T&gt; 中的“? super T”也代表某个参数，不知道这个参数是什么，只知道它是T的超类，所以此时添加T或者任何T的超类都不安全，但这个参数的下限是T啊，就是最差也是个List<T>，所以这时存T及其子类是安全的；但其擦除为List<Object>,所以只能读出Object类型。</p>
</blockquote>
<?>代表着类型未知，但是我们的确需要对于类型的描述再精确一点，我们希望在一个范围内确定类别，比如类型 A 及类型 A 的子类都可以。<? extends T> 表示类型的上界，表示参数化类型的可能是T或是T的子类。

**上界<? extends T>不能往里存，只能往外取**：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Human</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grandson</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;? extends Father&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//! list.add(new Son()); // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
List<? extends Father> 表示 “具有任何从Son继承类型的列表”，编译器无法确定List所持有的类型，所以无法安全的向其中添加对象。可以添加null,因为null 可以表示任何类型。所以List 的add 方法不能添加任何有意义的元素，但是可以接受现有的子类型List 赋值。
你也许试图这样做：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Father&gt; list = <span class="keyword">new</span> LinkedList&lt;Son&gt;();</span><br><span class="line"><span class="comment">//! list.add(new Son()); // 编译错误</span></span><br></pre></td></tr></table></figure>
即使你指明了为Son类型，也不能用add方法添加一个Son对象。list中为什么不能加入Father类和Father类的子类呢，我们来分析下。

List<? extends Father>表示上限是Father,下面这样的赋值都是合法的
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Father&gt; list1 = <span class="keyword">new</span> ArrayList&lt;Father&gt;();</span><br><span class="line">List&lt;? extends Father&gt; list2 = <span class="keyword">new</span> ArrayList&lt;Son&gt;();</span><br><span class="line">List&lt;? extends Father&gt; list3 = <span class="keyword">new</span> ArrayList&lt;Grandson&gt;();</span><br></pre></td></tr></table></figure>
如果List<? extends Father>支持add方法的话：
- list1可以add Father和所有Father的子类；
- list2可以add Son和所有Son的子类；
- list3可以add Grandson和所有Grandson的子类。
下面代码是编译不通过的：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1.add(<span class="keyword">new</span> Father());<span class="comment">//error</span></span><br><span class="line">list1.add(<span class="keyword">new</span> Son());   <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
原因是编译器只知道容器内是Father或者它的派生类，但具体是什么类型不知道。可能是Father？可能是Son？也可能是LeiFeng，XiaoMing？编译器在看到后面用Father赋值以后，集合里并没有限定参数类型是“Father“。而是标上一个占位符：CAP#1，来表示捕获一个Father或Father的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Son或者Grandson或者Father编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。

但是，这种形式还是很有用的，虽然不能使用add方法，但是可以在初始化的时候一个Season指定不同的类型。比如：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Father&gt; list1 = getFatherList();</span><br><span class="line"><span class="comment">//getFatherList方法会返回一个Father的子类的list</span></span><br></pre></td></tr></table></figure>
另外，由于我们已经保证了List中保存的是Father类或者他的某一个子类，所以，可以用get方法直接获得值：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? extends Father&gt; list1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Father father = list1.get(<span class="number">0</span>);<span class="comment">//读取出来的东西只能存放在Father或它的基类里。</span></span><br><span class="line">Object object = list1.get(<span class="number">0</span>);<span class="comment">//读取出来的东西只能存放在Father或它的基类里。</span></span><br><span class="line">Human human = list1.get(<span class="number">0</span>);  <span class="comment">//读取出来的东西只能存放在Father或它的基类里。</span></span><br><span class="line">Son son = (Son)list1.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
拓展：[<E extends ClassA> 与 <? extends ClassA>有什么区别？](https://stackoverflow.com/questions/897935/when-do-java-generics-require-extends-t-instead-of-t-and-is-there-any-down)

## 有下限的通配符 <? super T>


`<? super T>` 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object。

**下界<? super T>不能往外取，只能往里存**:

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">super</span> Father&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> Father());</span><br><span class="line">list.add(<span class="keyword">new</span> Human());<span class="comment">//compile error </span></span><br><span class="line">list.add(<span class="keyword">new</span> Son());</span><br><span class="line">Father person1 = list.get(<span class="number">0</span>);<span class="comment">//compile error </span></span><br><span class="line">Son son = list.get(<span class="number">0</span>);<span class="comment">//compile error </span></span><br><span class="line">Object object1 = list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
super只能添加Father和Father的子类，不能添加Father的父类，读取出来的东西只能存放在Object类里。因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然最小元素都是Father的基类，那往里存粒度比Father小的都可以。出于对类型安全的考虑，我们可以加入Father对象或者其任何子类（如Son）对象，但由于编译器并不知道List的内容究竟是Father的哪个超类，因此不允许加入特定的任何超类（如Human）。

而当我们读取的时候，编译器在不知道是什么类型的情况下只能返回Object对象，因为Object是任何Java类的最终祖先类。但这样的话，元素的类型信息就全部丢失了。

### PECS原则
最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：
- 频繁往外读取内容的，适合用上界Extends；
- 经常往里插入的，适合用下界Super。

## 总结
- extends 可用于返回类型限定，不能用于参数类型限定（换句话说：? extends xxx 只能用于方法返回类型限定，jdk能够确定此类的最小继承边界为xxx，只要是这个类的父类都能接收，但是传入参数无法确定具体类型，只能接受null的传入）。
- super 可用于参数类型限定，不能用于返回类型限定（换句话说：? supper xxx 只能用于方法传参，因为jdk能够确定传入为xxx的子类，返回只能用Object类接收）。
- ? 既不能用于方法参数传入，也不能用于方法返回。

# 泛型的擦除
当开始更深入地钻研泛型时，会发现有大量的东西初看起来是没有意义的。例如，尽管可以声明 ArrayList.class，但是不能声明 ArrayList<Integer>.class。请考虑下面的情况：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErasedTypeEquivalence</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Class c1 = <span class="keyword">new</span> ArrayList&lt;String&gt;().getClass();</span><br><span class="line">    Class c2 = <span class="keyword">new</span> ArrayList&lt;Integer&gt;().getClass();</span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
**Java泛型是使用擦除来实现的**，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象。因此List<String>和List<Integer>在运行时事实上是相同的类型。这两种形式都被擦除成它们的“原生”类型，即List。理解擦除以及应该如何处理它，是你在学习Java泛型时面临的最大障碍，这也是我们在本节将要探讨的内容。

Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，变成原始类型，这个过程就是类型擦除。

原始类型就是擦除去了泛型信息，最后在字节码中的类型变量的真正类型，无论何时定义一个泛型，相应的原始类型都会被自动提供，类型变量擦除，并使用其限定类型（无限定的变量用Object）替换。例如：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Pair&lt;T&gt; &#123;  </span><br><span class="line">    private T value;  </span><br><span class="line">    public T getValue() &#123;  </span><br><span class="line">        return value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void setValue(T  value) &#123;  </span><br><span class="line">        this.value &#x3D; value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
编译之后的原始类型：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
因为在Pair<T>中，T 是一个无限定的类型变量，所以用Object替换，其结果就是一个普通的类，如同泛型加入Java语言之前的已经实现的样子。在程序中可以包含不同类型的Pair，如Pair<String>或Pair<Integer>，但是擦除类型后他们的就成为原始的Pair类型了，原始类型都是Object。如果类型变量有限定，那么原始类型就用第一个边界的类型变量类替换。再比如：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Top</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Low</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">c</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">d</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TopLowImpl</span> <span class="keyword">implements</span> <span class="title">Top</span>, <span class="title">Low</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Top::a()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Top::b()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Low::c()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">d</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Low::d()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E25_Bounds</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Top&gt; <span class="function"><span class="keyword">void</span> <span class="title">top</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        obj.a();</span><br><span class="line">        obj.b();</span><br><span class="line">        <span class="comment">//! obj.c(); // 编译错误</span></span><br><span class="line">        <span class="comment">//! obj.d(); // 编译错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &lt;T extends Low&gt; <span class="function"><span class="keyword">void</span> <span class="title">low</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//! obj.a(); // 编译错误</span></span><br><span class="line">        <span class="comment">//! obj.b(); // 编译错误</span></span><br><span class="line">        obj.c();</span><br><span class="line">        obj.d();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TopLowImpl tli = <span class="keyword">new</span> TopLowImpl();</span><br><span class="line">        top(tli); <span class="comment">// tli被擦除为Top,无法调用c、d方法</span></span><br><span class="line">        low(tli); <span class="comment">// tli被擦除为Low,无法调用a、b方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Top::a()</span></span><br><span class="line"><span class="comment">Top::b()</span></span><br><span class="line"><span class="comment">Low::c()</span></span><br><span class="line"><span class="comment">Low::d()</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
要理解上面那种行为似乎有些困难，我们会发现这种称之为擦除的效果类似于向上转型，我自己的理解就是向上转型，因为对象已经建立了，是TopLowImpl类型的，擦除并不能在内存里改变对象的属性，只是在引用级别将其擦除为Top和Low，在这里不就是向上转型吗？记住，擦除发生在引用级别。

另外在调用泛型方法时，参数可以指定泛型，也可以不指定泛型。
- 在不指定泛型的情况下，泛型变量的类型为该方法中的几种类型的同一父类的最小级，直到Object
- 在指定泛型的情况下，该方法的几种类型必须是该泛型的实例的类型或者其子类
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这是一个简单的泛型方法  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">add</span><span class="params">(T x,T y)</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> y;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">         <span class="comment">/**不指定泛型的时候*/</span>  </span><br><span class="line">         <span class="keyword">int</span> i = Test.add(<span class="number">1</span>, <span class="number">2</span>);         <span class="comment">// 这两个参数都是Integer，所以T为Integer类型  </span></span><br><span class="line">        Number f = Test.add(<span class="number">1</span>, <span class="number">1.2</span>);    <span class="comment">// 这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Number  </span></span><br><span class="line">        Object o = Test.add(<span class="number">1</span>, <span class="string">&quot;asd&quot;</span>);  <span class="comment">// 这两个参数一个是Integer，一个是Float，所以取同一父类的最小级，为Object  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**指定泛型的时候*/</span>  </span><br><span class="line">        <span class="keyword">int</span> a = Test.&lt;Integer&gt;add(<span class="number">1</span>, <span class="number">2</span>);       <span class="comment">// 指定了Integer，所以只能为Integer类型或者其子类  </span></span><br><span class="line">        <span class="comment">//! int b = Test.&lt;Integer&gt;add(1, 2.2); // 编译错误，指定了Integer，不能为Float  </span></span><br><span class="line">        Number c = Test.&lt;Number&gt;add(<span class="number">1</span>, <span class="number">2.2</span>);   <span class="comment">// 指定为Number，所以可以为Integer和Float  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实在泛型类中，不指定泛型的时候，也差不多，只不过这个时候的泛型为Object，就比如ArrayList中，如果不指定泛型，那么这个ArrayList可以存储任意的对象：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">    ArrayList list = <span class="keyword">new</span> ArrayList();  </span><br><span class="line">    list.add(<span class="number">1</span>);  </span><br><span class="line">    list.add(<span class="string">&quot;121&quot;</span>);  </span><br><span class="line">    list.add(<span class="keyword">new</span> Date());  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

# 泛型（擦除）的问题
## 基本数据类型不能作为类型参数
不能用类型参数替换基本类型。就比如，没有ArrayList<double>，只有ArrayList<Double>。因为当类型擦除后，ArrayList的原始类型变为Object，但是Object类型不能存储double值，只能引用Double的值。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListOfInt</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      li.add(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : li)</span><br><span class="line">      System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">0 1 2 3 4</span></span><br><span class="line"><span class="comment">*/</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>

- 8种基本类型及其封装类：

| 数据类型 | 包 装 类  | 字节长度 |  默 认 值  |
| :------: | :-------: | :------: | :--------: |
|   int    |  Integer  |    4     |     0      |
|  short   |   Short   |    2     |     0      |
|   long   |   Long    |    8     |   0l或0L   |
|   byte   |   Byte    |    1     |     0      |
|  float   |   Float   |    4     | 0.0F或0.0f |
|  double  |  Double   |    8     |    0.0     |
|   char   | Character |    2     |   u0000    |
| boolean  |  Boolean  |    1     |   false    |

## 编译时集合的instanceof
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
因为类型擦除之后，ArrayList<String>只剩下原始类型，泛型信息String不存在了。那么，编译时进行类型查询的时候使用下面的方法是错误的
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(arrayList <span class="keyword">instanceof</span> ArrayList&lt;String&gt;);</span><br></pre></td></tr></table></figure>

## 实现参数化接口（基类劫持了接口）
一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口。下面是产生这种冲突的情况：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"> <span class="comment">// Hourly不能编译</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
Hourly不能编译，因为擦除会将 Payable<Employee>和 Payable<Hourly>简化为相同的类Payable，这样，上面的代码就意味着在重复两次地实现相同的接口。十分有趣的是，如果从Payable的两种用法中都移除掉泛型参数（就像编译器在擦除阶段所做的那样）这段代码就可以编译。

## 擦除与方法重载
下面的程序是不能编译的，即使编译它是一种合理的尝试：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
由于擦除的原因，重载方法将产生相同的类型签名。与此不同的是，当被擦除的参数不能产生唯一的参数列表时，必须提供明显有区别的方法名：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UseList2</span>&lt;<span class="title">W</span>,<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(List&lt;T&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(List&lt;W&gt; v)</span> </span>&#123;&#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
## 类型擦除与多态的冲突和解决方法
现在有这样一个泛型类：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> T value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后我们想要一个子类继承它。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">Pair</span>&lt;<span class="title">Date</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
在这个子类中，我们设定父类的泛型类型为Pair<Date>，在子类中，我们重写了父类的两个方法，我们的原意是这样的：将父类的泛型类型限定为Date，那么父类里面的两个方法的参数都为Date类型。
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.value = value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以，我们在子类中重写这两个方法一点问题也没有，实际上，从他们的@Override标签中也可以看到，一点问题也没有，实际上是这样的吗？

分析：实际上，类型擦除后，父类的的泛型类型全部变为了原始类型Object，所以父类编译之后会变成下面的样子：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Object value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Object  value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
再看子类的两个重写的方法的类型：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">super</span>.setValue(value);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
先来分析setValue方法，父类的类型是Object，而子类的类型是Date，参数类型不一样，这如果是在普通的继承关系中，根本就不会是重写，而是重载。我们在一个main方法测试一下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">        DateInter dateInter = <span class="keyword">new</span> DateInter();  </span><br><span class="line">        dateInter.setValue(<span class="keyword">new</span> Date());                  </span><br><span class="line">        <span class="comment">//! dateInter.setValue(new Object()); //编译错误  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果是重载，那么子类中两个setValue方法，一个是参数Object类型，一个是Date类型，可是我们发现，根本就没有这样的一个子类继承自父类的Object类型参数的方法。所以说，的确是重写了，而不是重载了。为什么会这样呢？原因是这样的，我们传入父类的泛型类型是Date，Pair<Date>，我们的本意是将泛型类变为如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Date value;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Date value)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.value = value;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后在子类中重写参数类型为Date的那两个方法，实现继承中的多态。可是由于种种原因，虚拟机并不能将泛型类型变为Date，只能将类型擦除掉，变为原始类型Object。这样，我们的本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突。JVM知道你的本意吗？知道！！！可是它能直接实现吗，不能！！！如果真的不能的话，那我们怎么去重写我们想要的Date类型参数的方法啊。

于是JVM采用了一个特殊的方法，来完成这项功能，那就是桥方法。首先，我们用javap -c className的方式反编译下DateInter子类的字节码，结果如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">DateInter</span> <span class="keyword">extends</span> <span class="title">com</span>.<span class="title">tao</span>.<span class="title">test</span>.<span class="title">Pair</span>&lt;<span class="title">java</span>.<span class="title">util</span>.<span class="title">Date</span>&gt; </span>&#123;  </span><br><span class="line">  com.tao.test.DateInter();  </span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #8                  // Method com/tao/test/Pair.&quot;&lt;init&gt;&quot;:()V  </span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.util.Date)</span></span>;  <span class="comment">// 我们重写的setValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: invokespecial #16                 // Method com/tao/test/Pair.setValue:(Ljava/lang/Object;)V  </span><br><span class="line">       <span class="number">5</span>: <span class="keyword">return</span>  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.util.<span class="function">Date <span class="title">getValue</span><span class="params">()</span></span>;    <span class="comment">// 我们重写的getValue方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokespecial #23                 // Method com/tao/test/Pair.getValue:()Ljava/lang/Object;  </span><br><span class="line">       4: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       <span class="number">7</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> java.lang.<span class="function">Object <span class="title">getValue</span><span class="params">()</span></span>;   <span class="comment">// 编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       1: invokevirtual #28                 // Method getValue:()Ljava/util/Date 去调用我们重写的getValue方法;  </span><br><span class="line">       <span class="number">4</span>: areturn  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(java.lang.Object)</span></span>; <span class="comment">// 编译时由编译器生成的巧方法  </span></span><br><span class="line">    Code:  </span><br><span class="line">       <span class="number">0</span>: aload_0  </span><br><span class="line">       <span class="number">1</span>: aload_1  </span><br><span class="line">       2: checkcast     #26                 // class java/util/Date  </span><br><span class="line">       5: invokevirtual #30                 // Method setValue:(Ljava/util/Date; 去调用我们重写的setValue方法)V  </span><br><span class="line">       <span class="number">8</span>: <span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从编译的结果来看，我们本意重写setValue和getValue方法的子类，竟然有4个方法，其实不用惊奇，最后的两个方法，就是编译器自己生成的桥方法。可以看到桥方法的参数类型都是Object，也就是说，子类中真正覆盖父类两个方法的就是这两个我们看不到的桥方法。而打在我们自己定义的setvalue和getValue方法上面的@Oveerride只不过是假象。而桥方法的内部实现，就只是去调用我们自己重写的那两个方法。所以，虚拟机巧妙的使用了桥方法，来解决了类型擦除和多态的冲突。不过，要提到一点，这里面的setValue和getValue这两个桥方法的意义又有不同。setValue方法是为了解决类型擦除与多态之间的冲突。而getValue却有普遍的意义，怎么说呢，如果这是一个普通的继承关系，那么父类的setValue方法如下：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectgetValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
而子类重写的方法是：
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getValue();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其实这在普通的类继承中也是普遍存在的重写，这就是协变。

并且，还有一点也许会有疑问，子类中的桥方法Object getValue()和Date getValue()是同时存在的，可是如果是常规的两个方法，他们的方法签名是一样的，也就是说虚拟机根本不能分辨这两个方法。如果是我们自己编写Java代码，这样的代码是无法通过编译器的检查的，但是虚拟机却是允许这样做的，因为虚拟机通过参数类型和返回类型来确定一个方法，所以编译器为了实现泛型的多态允许自己做这个看起来“不合法”的事情，然后交给虚拟器去区别。

> 参考：
>
> 1. 《Java编程思想》
> 2. [Java 泛型详解](https://blog.csdn.net/s10461/article/details/53941091)
> 3. [Java中<? extends T>和<? super T>的理解](https://www.cnblogs.com/chenxibobo/p/9655236.html)
> 4. [Java 泛型，你了解类型擦除吗？](https://blog.csdn.net/briblue/article/details/76736356)
> 5. [Java泛型类型擦除以及类型擦除带来的问题](https://www.cnblogs.com/wuqinglong/p/9456193.html)
> 6. [Java泛型（二） 协变与逆变](https://www.jianshu.com/p/2bf15c5265c5)
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%B3%9B%E5%9E%8B/" rel="tag"><i class="fa fa-tag"></i> 泛型</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/02/18/ThinkingInJava_10_%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/" rel="prev" title="类型信息">
                  <i class="fa fa-chevron-left"></i> 类型信息
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/03/05/ThinkingInJava_12_%E6%95%B0%E7%BB%84/" rel="next" title="数组">
                  数组 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saltedfish</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">398k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:03</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
