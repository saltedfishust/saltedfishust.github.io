<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<meta name="hexo-config" content="{&quot;hostname&quot;:&quot;example.com&quot;,&quot;root&quot;:&quot;/&quot;,&quot;images&quot;:&quot;/images&quot;,&quot;scheme&quot;:&quot;Pisces&quot;,&quot;version&quot;:&quot;8.3.0&quot;,&quot;exturl&quot;:false,&quot;sidebar&quot;:{&quot;position&quot;:&quot;left&quot;,&quot;display&quot;:&quot;post&quot;,&quot;padding&quot;:18,&quot;offset&quot;:12},&quot;copycode&quot;:true,&quot;bookmark&quot;:{&quot;enable&quot;:false,&quot;color&quot;:&quot;#222&quot;,&quot;save&quot;:&quot;auto&quot;},&quot;fancybox&quot;:false,&quot;mediumzoom&quot;:false,&quot;lazyload&quot;:false,&quot;pangu&quot;:false,&quot;comments&quot;:{&quot;style&quot;:&quot;tabs&quot;,&quot;active&quot;:null,&quot;storage&quot;:true,&quot;lazyload&quot;:false,&quot;nav&quot;:null},&quot;motion&quot;:{&quot;enable&quot;:true,&quot;async&quot;:false,&quot;transition&quot;:{&quot;post_block&quot;:&quot;fadeIn&quot;,&quot;post_header&quot;:&quot;fadeInDown&quot;,&quot;post_body&quot;:&quot;fadeInDown&quot;,&quot;coll_header&quot;:&quot;fadeInLeft&quot;,&quot;sidebar&quot;:&quot;fadeInUp&quot;}},&quot;prism&quot;:false,&quot;i18n&quot;:{&quot;placeholder&quot;:&quot;搜索...&quot;,&quot;empty&quot;:&quot;没有找到任何搜索结果：${query}&quot;,&quot;hits_time&quot;:&quot;找到 ${hits} 个搜索结果（用时 ${time} 毫秒）&quot;,&quot;hits&quot;:&quot;找到 ${hits} 个搜索结果&quot;}}">
<meta name="description" content="有向图的可达性（遍历）与无向图不同，有向图的遍历（或者叫排列）基于DFS，分为以下三种： 前序遍历：根最先后序遍历：根最后逆后序遍历（拓扑排序） 拓扑排序是将DAG中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边&lt;u,v&gt;∈E(G)，则 u 在线性序列中出现在 v 之前； 定理1：当且仅当一幅有向图是无环有向图(DAG)时它才能进行拓扑排序（即拓扑有序）； 定理2：一">
<meta property="og:type" content="article">
<meta property="og:title" content="加权有向图的遍历（前序、后序、拓扑）和最短路径树（Dij、BF、Flyod）">
<meta property="og:url" content="http://example.com/2019/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE/index.html">
<meta property="og:site_name" content="Saltedfish">
<meta property="og:description" content="有向图的可达性（遍历）与无向图不同，有向图的遍历（或者叫排列）基于DFS，分为以下三种： 前序遍历：根最先后序遍历：根最后逆后序遍历（拓扑排序） 拓扑排序是将DAG中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边&lt;u,v&gt;∈E(G)，则 u 在线性序列中出现在 v 之前； 定理1：当且仅当一幅有向图是无环有向图(DAG)时它才能进行拓扑排序（即拓扑有序）； 定理2：一">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://note.youdao.com/yws/api/personal/file/026AAEFCB08943328E9070CC30B7DCD2?method=download&shareKey=6fd7014319adc0f0dacb661563b642d1">
<meta property="article:published_time" content="2019-09-01T14:50:15.000Z">
<meta property="article:modified_time" content="2021-01-25T15:22:32.000Z">
<meta property="article:author" content="Saltedfish">
<meta property="article:tag" content="Dijkstra">
<meta property="article:tag" content="Bellman-Ford">
<meta property="article:tag" content="Flyod">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note.youdao.com/yws/api/personal/file/026AAEFCB08943328E9070CC30B7DCD2?method=download&shareKey=6fd7014319adc0f0dacb661563b642d1">


<link rel="canonical" href="http://example.com/2019/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE/">



<meta name="hexo-config-page" content="{&quot;sidebar&quot;:&quot;&quot;,&quot;isHome&quot;:false,&quot;isPost&quot;:true,&quot;lang&quot;:&quot;zh-CN&quot;}">
<meta name="hexo-config-calendar" content="">
<title>加权有向图的遍历（前序、后序、拓扑）和最短路径树（Dij、BF、Flyod） | Saltedfish</title><script data-pjax src="/js/load-config.js"></script>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Saltedfish</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to the home of saltedfish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">116</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">5</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">59</span></a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%EF%BC%88%E9%81%8D%E5%8E%86%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">有向图的可达性（遍历）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A%E6%A0%B9%E6%9C%80%E5%85%88"><span class="nav-number">1.1.</span> <span class="nav-text">前序遍历：根最先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%9A%E6%A0%B9%E6%9C%80%E5%90%8E"><span class="nav-number">1.2.</span> <span class="nav-text">后序遍历：根最后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text">逆后序遍历（拓扑排序）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%A0%91%EF%BC%88SPT%EF%BC%89"><span class="nav-number">2.</span> <span class="nav-text">最短路径树（SPT）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%88%E6%97%A2%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%8C%E6%9B%B4%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E7%8E%AF%EF%BC%89%EF%BC%9ADijkstra"><span class="nav-number">2.1.</span> <span class="nav-text">单源最短路径算法（既不能处理负权边，更不能处理负权环）：Dijkstra</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%88%E5%8D%B3%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E7%8E%AF%EF%BC%89%EF%BC%9ABellman-Ford"><span class="nav-number">2.2.</span> <span class="nav-text">单源最短路径算法（即可以处理负权边，也可以处理负权环）：Bellman-Ford</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8C%E5%85%A8%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95%EF%BC%88%E5%8F%AF%E4%BB%A5%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%EF%BC%8C%E4%BD%86%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E7%8E%AF%EF%BC%89%EF%BC%9AFlyod"><span class="nav-number">2.3.</span> <span class="nav-text">完全最短路径算法（可以处理负权边，但不能处理负权环）：Flyod</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9A%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E7%9A%84%E6%9C%80%E4%BC%98SPT%E7%AE%97%E6%B3%95%EF%BC%9A%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.</span> <span class="nav-text">补充：加权有向无环图的最优SPT算法：拓扑排序+松弛操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.</span> <span class="nav-text">实现</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Saltedfish"
      src="/uploads/avatar.png">
  <p class="site-author-name" itemprop="name">Saltedfish</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">59</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">116</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2019/09/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%8A%A0%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.png">
      <meta itemprop="name" content="Saltedfish">
      <meta itemprop="description" content="Stay hungry, stay foolish">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Saltedfish">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          加权有向图的遍历（前序、后序、拓扑）和最短路径树（Dij、BF、Flyod）
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-01 22:50:15" itemprop="dateCreated datePublished" datetime="2019-09-01T22:50:15+08:00">2019-09-01</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2021-01-25 23:22:32" itemprop="dateModified" datetime="2021-01-25T23:22:32+08:00">2021-01-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>21k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>38 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="有向图的可达性（遍历）"><a href="#有向图的可达性（遍历）" class="headerlink" title="有向图的可达性（遍历）"></a>有向图的可达性（遍历）</h2><p>与无向图不同，有向图的遍历（或者叫排列）基于DFS，分为以下三种：</p>
<h3 id="前序遍历：根最先"><a href="#前序遍历：根最先" class="headerlink" title="前序遍历：根最先"></a>前序遍历：根最先</h3><h3 id="后序遍历：根最后"><a href="#后序遍历：根最后" class="headerlink" title="后序遍历：根最后"></a>后序遍历：根最后</h3><h3 id="逆后序遍历（拓扑排序）"><a href="#逆后序遍历（拓扑排序）" class="headerlink" title="逆后序遍历（拓扑排序）"></a>逆后序遍历（拓扑排序）</h3><ul>
<li>拓扑排序是将DAG中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边<code>&lt;u,v&gt;∈E(G)</code>，则 u 在线性序列中出现在 v 之前；</li>
<li>定理1：当且仅当一幅有向图是无环有向图(DAG)时它才能进行拓扑排序（即拓扑有序）；</li>
<li>定理2：一幅有向无环图的拓扑顺序即为所有顶点的逆后续排列；</li>
<li>注意：在拓扑排序之前必须检查图中有没有环，如果有则返回null<span id="more"></span>
<h2 id="最短路径树（SPT）"><a href="#最短路径树（SPT）" class="headerlink" title="最短路径树（SPT）"></a>最短路径树（SPT）</h2><blockquote>
<p>相关题目：acwing 849 850 851 853 1488</p>
</blockquote>
</li>
</ul>
<p><img src="https://note.youdao.com/yws/api/personal/file/026AAEFCB08943328E9070CC30B7DCD2?method=download&shareKey=6fd7014319adc0f0dacb661563b642d1" alt="image"></p>
<blockquote>
<p>建议参考：算法系列——四种最短路算法：Floyd，Dijkstra，Bellman-Ford，SPFA - 吕清海的文章 - 知乎<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33162490">https://zhuanlan.zhihu.com/p/33162490</a></p>
</blockquote>
<h3 id="单源最短路径算法（既不能处理负权边，更不能处理负权环）：Dijkstra"><a href="#单源最短路径算法（既不能处理负权边，更不能处理负权环）：Dijkstra" class="headerlink" title="单源最短路径算法（既不能处理负权边，更不能处理负权环）：Dijkstra"></a>单源最短路径算法（既不能处理负权边，更不能处理负权环）：Dijkstra</h3><ul>
<li><p>Dij算法的思想其实跟prim算法类似，两种贪心算法都会用添加边的方式构造一棵树：Prim算法每次添加的是<strong>离树最近的的非树顶点</strong>，Dijkstra算法每次添加的都是<strong>离起点最近的非树顶点</strong>。同样对应于Prim算法的延时实现和即时实现，Dijkstra算法也有延时（优先队列）和即时（索引优先队列）两种实现，他们（指与 prim 的区别）代码中的唯一区别就是Dijkstra多了一个松弛的操作。其实Dij还有一种朴素版的实现，就是两层循环，不借助优先队列求最短横切边，自然时间复杂度就是 n^2 的。</p>
</li>
<li><p>Dij算法的基础在于<code>松弛</code>，根据距离起点的远近依次检查路径，即假设添加一条边总会使路径变得更长，而负权边的存在破坏了这个基础，所以Dij算法不能处理负权边。</p>
</li>
<li><p>Dij的算法复杂度：在一幅含有V个顶点，E条边的加权有向图中，使用Dij算法所需空间与<code>V</code>成正比，所需时间与<code>ElogV</code>成正比。</p>
</li>
</ul>
<h3 id="单源最短路径算法（即可以处理负权边，也可以处理负权环）：Bellman-Ford"><a href="#单源最短路径算法（即可以处理负权边，也可以处理负权环）：Bellman-Ford" class="headerlink" title="单源最短路径算法（即可以处理负权边，也可以处理负权环）：Bellman-Ford"></a>单源最短路径算法（即可以处理负权边，也可以处理负权环）：Bellman-Ford</h3><ul>
<li><p>如果<code>s -&gt; v</code>的有向路径上的任意一点m处于负权环上，则讨论<code>s -&gt; v</code>的最短路径没有意义，因为<code>m -&gt; m</code>可以构造任意小的路径；只有加权有向图中至少存在一条<code>s -&gt; v</code>的有向路径并且所有<code>s -&gt; v</code>的有向路径上的任意顶点都不存在于任何负权环中，<code>s -&gt; v</code>的最短路径才存在。</p>
</li>
<li><p>规定如下：</p>
<ul>
<li>对于起点不可达的顶点，最短路径为 <code>$ + \infty$</code></li>
<li>对于起点可达但路径上的某点属于一个负权环的顶点，最短路径为 <code>$ - \infty$</code></li>
<li>对于其他顶点，计算最短路径的权重以及最短路径树</li>
</ul>
</li>
<li><p>换言之，只有存在最短路径BF算法才会得出解，即给定源点 s，s无法到达任何负权环才能有最短路径解，否则检测到可达的负权环则程序终止，避免陷入死循环。 </p>
</li>
<li><p>对于一个含有 V 个顶点 E 条边的加权有向图以任意顺序放松有向图的所有边，重复 V 轮；在最坏情况下基于队列的Bellman-Ford算法解决最短路径问题（或者找到从源点可达的负权环），所需的时间与 <code>EV</code>成正比，空间和<code>V</code>成正比。</p>
</li>
<li><p>松弛 n-1 轮就能得到最短路径，如果第 n 轮还能松弛成功代表存在源点可达的负权环，这个时候不存在最短路径。</p>
</li>
</ul>
<h3 id="完全最短路径算法（可以处理负权边，但不能处理负权环）：Flyod"><a href="#完全最短路径算法（可以处理负权边，但不能处理负权环）：Flyod" class="headerlink" title="完全最短路径算法（可以处理负权边，但不能处理负权环）：Flyod"></a>完全最短路径算法（可以处理负权边，但不能处理负权环）：Flyod</h3><p>一种基于动态规划的多源最短路算法，其核心代码就是三层循环。算法复杂度较高，对于一个含有N个点的图，时间复杂度与<code>$N^3$</code>成正比。</p>
<h3 id="补充：加权有向无环图的最优SPT算法：拓扑排序-松弛操作"><a href="#补充：加权有向无环图的最优SPT算法：拓扑排序-松弛操作" class="headerlink" title="补充：加权有向无环图的最优SPT算法：拓扑排序+松弛操作"></a>补充：加权有向无环图的最优SPT算法：拓扑排序+松弛操作</h3><ul>
<li>相比Dij算法，AcyclicSP算法只需要按照拓扑顺序依次松弛每个点，每个点只会被松弛一次，因为当 from 被放松后，一定成立 <code>distTo[from] + edge.getWeight() &gt;= distTo[to]</code>，在算法结束前都成立；因为 from 松弛后, distTo[from] 就不会变了，而 distTo[to] 只会变小，所以当按照拓扑顺序松弛完所有的点后，最短路径就生成了。</li>
<li>这个算法的复杂度是线性的<code>E+V</code>。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">加权有向图的实现比加权无向图更加简单一些，区别就是每个点只存储以该点为起点的边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里为了简单，用0开始连续的数字代表顶点（顶点ID），实际的实现中应该设计成类 Node 的形式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V;      <span class="comment">// 顶点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;            <span class="comment">// 边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked; <span class="comment">// 用于遍历时标记用</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, TreeSet&lt;DirectedEdge&gt;&gt; adj; <span class="comment">// 邻接表用Hash表实现，key=Node_ID, value=相邻的边组成的链表(这里的实现是红黑二叉树)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedGraph</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.V = v;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">// 初始化哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; V; i++) &#123;</span><br><span class="line">            adj.put(i,<span class="keyword">new</span> TreeSet&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getV</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getE</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过起点和终点返回边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectedEdge <span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : adj.get(from))</span><br><span class="line">            <span class="keyword">if</span> (e.to == to)</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有这里与无向图不同</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(DirectedEdge e)</span> </span>&#123;</span><br><span class="line">        adj.get(e.from).add(e); <span class="comment">// 只添加作为起点的边</span></span><br><span class="line">        E++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 v 点所有的连接边，Iterable&lt;Edge&gt;方便遍历</span></span><br><span class="line">    <span class="function">Iterable&lt;DirectedEdge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adj.get(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回加权无向图中所有的边</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">edges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeSet&lt;DirectedEdge&gt; edges = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer,TreeSet&lt;DirectedEdge&gt;&gt; entry : adj.entrySet())</span><br><span class="line">            edges.addAll(entry.getValue());</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    有向图的可达性：与无向图不同，有向图的遍历（或者叫排列），基于无向图的DFS，分为以下三种</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// DFS</span></span><br><span class="line">    <span class="comment">// 1. preOrder                            前序遍历（DFS）：递归调用之前将顶点加入队列(先入先出，为了正序输出)</span></span><br><span class="line">    LinkedList&lt;Integer&gt; preQueue;</span><br><span class="line">    <span class="comment">// 2. postOrder                           后序遍历：递归调用之后将顶点加入队列（先入先出，为了正序输出）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; postQueue;</span><br><span class="line">    <span class="comment">// 3. reversePostOrder（topologicalOrder） 逆后序遍历：递归调用之后将顶点压入栈（先入后出，为了逆序输出）</span></span><br><span class="line">    LinkedList&lt;Integer&gt; reversePostStack;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     4. TopologicalOrder 拓扑排序：是将DAG中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v&gt;∈E(G)，则u在线性序列中出现在v之前</span></span><br><span class="line"><span class="comment">     定理1：当且仅当一幅有向图是无环有向图(DAG)时它才能进行拓扑排序（即拓扑有序）</span></span><br><span class="line"><span class="comment">     定理2：一幅有向无环图的拓扑顺序即为所有顶点的逆后续排列</span></span><br><span class="line"><span class="comment">     所以在拓扑排序之前必须检查图中有没有环，如果有则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthFirstSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[V]; <span class="comment">// 每次遍历之前懒惰初始化，每次都保证初始全是false</span></span><br><span class="line">        preQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        postQueue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        reversePostStack = <span class="keyword">new</span> LinkedList&lt;&gt;(); <span class="comment">// 无环时是拓扑排序，当有环时返回null</span></span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断有没有环，有环返回null，但实际中应该先判断有没有环，这里只是为了方便一起写</span></span><br><span class="line">        EdgeWeightedDirectedCycle cycle = <span class="keyword">new</span> EdgeWeightedDirectedCycle(<span class="keyword">this</span>); <span class="comment">// 注意后面的判断环的dfs方法里加了负权重环的判断，在这里应该删除</span></span><br><span class="line">        <span class="keyword">if</span> (cycle.hasCycle())</span><br><span class="line">            reversePostStack = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root)</span> </span>&#123;</span><br><span class="line">        preQueue.offer(root);</span><br><span class="line">        marked[root] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : <span class="keyword">this</span>.adj(root)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!marked[edge.to])</span><br><span class="line">                dfs(edge.to);</span><br><span class="line">        &#125;</span><br><span class="line">        postQueue.offer(root);</span><br><span class="line">        reversePostStack.push(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UndirectedGraph&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;V=&quot;</span> + V +</span><br><span class="line">                <span class="string">&quot;, E=&quot;</span> + E +</span><br><span class="line">                <span class="string">&quot;, adj=&quot;</span> + adj +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectedEdge</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">DirectedEdge</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> from;</span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DirectedEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.from = from;</span><br><span class="line">        <span class="keyword">this</span>.to = to;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFrom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> from;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getWeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里定义大小关系，平行边定义为相等，因为前面用的set存邻接边，即不允许添加平行边</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(DirectedEdge that)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.from == that.from &amp;&amp; <span class="keyword">this</span>.to == that.to)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight &lt; that.weight)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.weight &gt; that.weight)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DirectedEdge&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;from=&quot;</span> + from +</span><br><span class="line">                <span class="string">&quot;, to=&quot;</span> + to +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有向加权图最短路径树(SPT):</span></span><br><span class="line"><span class="comment"> *      1. 单源最短路径：Dijkstra</span></span><br><span class="line"><span class="comment"> *      2. 单源最短路径：Bellman-Ford</span></span><br><span class="line"><span class="comment"> *      3. 完全最短路径：Flyod</span></span><br><span class="line"><span class="comment"> *      4. 补充：加权有向无环图的最优SPT算法：拓扑排序+松弛操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dij算法的思想其实跟prim算法类似，两种算法都会用添加边的方式构造一棵树：Prim算法每次添加的是离树最近的的非树顶点，</span></span><br><span class="line"><span class="comment"> * Dijkstra算法每次添加的都是离起点最近的非树顶点。同样对应于Prim算法的延时实现和即时实现，Dijkstra算法也有延时（优先队列）</span></span><br><span class="line"><span class="comment"> * 和即时（索引优先队列）两种实现，他们代码中的唯一区别就是Dijkstra多了一个松弛的操作。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo; <span class="comment">// 到此点路径（指向此点的边），为了记录路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;       <span class="comment">// 到此点的路径权重</span></span><br><span class="line">    <span class="keyword">private</span> IndexMinPriorityQueue indexMinPq; <span class="comment">// 索引优先队列，将顶点ID和到此点的路径权重关联（即时实现）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dijkstra</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.getV()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getV()];</span><br><span class="line">        indexMinPq = <span class="keyword">new</span> IndexMinPriorityQueue&lt;&gt;(graph.getV());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++)</span><br><span class="line">            distTo[v] = Double.MAX_VALUE; <span class="comment">// 先将最短距离置为最大值</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>; <span class="comment">// 设置源点距离为0</span></span><br><span class="line"></span><br><span class="line">        indexMinPq.insert(s ,<span class="number">0.0</span>); <span class="comment">// 用顶点s和权重0初始化indexPq</span></span><br><span class="line">        <span class="keyword">while</span> (!indexMinPq.isEmpty())</span><br><span class="line">            relax(graph, indexMinPq.delMin());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具函数:松弛操作，并更新索引优先队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : graph.adj(v)) &#123; <span class="comment">// 遍历所有邻接边</span></span><br><span class="line">            <span class="keyword">int</span> w = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (distTo[edge.from] + edge.getWeight() &lt; distTo[w]) &#123; <span class="comment">// 这里多加了edge.getWeight()进行松弛</span></span><br><span class="line">                edgeTo[w] = edge;</span><br><span class="line">                distTo[w] = distTo[edge.from] + edge.getWeight();</span><br><span class="line">                <span class="keyword">if</span> (indexMinPq.contains(w))  <span class="comment">// 找到非树上的点离源点更近的点，更新或添加</span></span><br><span class="line">                    indexMinPq.change(w,distTo[w]); <span class="comment">// 更新</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    indexMinPq.insert(w,distTo[w]); <span class="comment">// 添加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否存在最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;DirectedEdge&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from])</span><br><span class="line">            pathStack.push(e);</span><br><span class="line">        <span class="keyword">return</span> pathStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AcyclicSP算法（仅适用于加权DAG）；</span></span><br><span class="line"><span class="comment"> * 相比Dijkstra算法，只需要按照拓扑顺序依次松弛每个点，每个点只会被松弛一次，因为当from被放松后，一定成立 distTo[from] + edge.getWeight() &gt;= distTo[to]；</span></span><br><span class="line"><span class="comment"> * 在算法结束前都成立，因为from松弛后,distTo[from]就不会变了，而distTo[to]只会变小，所以当按照拓扑顺序松弛完所有的点后，最短路径就生成了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AcyclicSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo; <span class="comment">// 到此点路径（指向此点的边）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;       <span class="comment">// 到此点的路径权重</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里是寻找最短路径的实现，寻找最长路径只需要把distTo[]初始化为Double.MIN_VALUE，并改变relax()中不等式的方向即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcyclicSP</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.getV()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getV()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++)</span><br><span class="line">            distTo[v] = Double.MAX_VALUE; <span class="comment">// 先将最短距离置为最大值</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>; <span class="comment">// 设置源点距离为0</span></span><br><span class="line"></span><br><span class="line">        graph.depthFirstSearch();</span><br><span class="line">        LinkedList&lt;Integer&gt; topological = graph.reversePostStack; <span class="comment">// 获取拓扑排列</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : topological) <span class="comment">// 按照拓扑顺序遍历所有的点，每个点只遍历一次</span></span><br><span class="line">            relax(graph,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具函数:松弛操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : graph.adj(v)) &#123; <span class="comment">// 遍历所有邻接边</span></span><br><span class="line">            <span class="keyword">int</span> w = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (distTo[edge.from] + edge.getWeight() &lt; distTo[w]) &#123; <span class="comment">// 找到非树上的点离源点更近的点，更新或添加</span></span><br><span class="line">                edgeTo[w] = edge;</span><br><span class="line">                distTo[w] = distTo[edge.from] + edge.getWeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否存在最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;DirectedEdge&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from])</span><br><span class="line">            pathStack.push(e);</span><br><span class="line">        <span class="keyword">return</span> pathStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BF算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BellmanFordSP</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;        <span class="comment">// 到此点路径（指向此点的边）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] distTo;              <span class="comment">// 到此点的路径权重</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; queue;    <span class="comment">// 正在被放松的顶点队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onQueue;            <span class="comment">// 该顶点是否在队列中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cost;                     <span class="comment">// relax()被调用的次数</span></span><br><span class="line">    <span class="keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle; <span class="comment">// edgeTo[]中的边是否形成负权重环</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BellmanFordSP</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.getV()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getV()];</span><br><span class="line">        onQueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getV()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++)</span><br><span class="line">            distTo[v] = Double.POSITIVE_INFINITY;  <span class="comment">// 正无穷</span></span><br><span class="line">        distTo[s] = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Bellman-Ford algorithm：按任意顺序松弛有向图的所有边</span></span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(s);</span><br><span class="line">        onQueue[s] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; !hasNegativeCycle()) &#123; <span class="comment">// 队列为空代表成功找到了最短路径，如果在V轮后队列非空则一定存在负权环，循环终止</span></span><br><span class="line">            <span class="keyword">int</span> v = queue.poll();</span><br><span class="line">            onQueue[v] = <span class="keyword">false</span>;</span><br><span class="line">            relax(graph, v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 松弛操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : graph.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to;</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] &gt; distTo[v] + e.getWeight()) &#123;</span><br><span class="line">                distTo[w] = distTo[v] + e.getWeight();</span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                <span class="keyword">if</span> (!onQueue[w]) &#123; <span class="comment">// 保证队列中不含重复的点，并且只将成功放松的边指向的所有顶点加入队列</span></span><br><span class="line">                    queue.offer(w);</span><br><span class="line">                    onQueue[w] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (++cost % graph.getV() == <span class="number">0</span>) &#123;  <span class="comment">// 周期性的检查edgeTo[]表示的子图中是否存在负权重环</span></span><br><span class="line">                findNegativeCycle();</span><br><span class="line">                <span class="keyword">if</span> (hasNegativeCycle()) <span class="keyword">return</span>; <span class="comment">// 如果存在环直接返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否存在最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[v] &lt; Double.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;DirectedEdge&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[v]; e != <span class="keyword">null</span>; e = edgeTo[e.from])</span><br><span class="line">            pathStack.push(e);</span><br><span class="line">        <span class="keyword">return</span> pathStack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">negativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用edgeTo[]中的边表示一个有向加权图，检查edgeTo[]表示的子图中是否存在负权重环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findNegativeCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = edgeTo.length;</span><br><span class="line">        DirectedGraph spt = <span class="keyword">new</span> DirectedGraph(V);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) <span class="comment">// 构造一个图</span></span><br><span class="line">            <span class="keyword">if</span> (edgeTo[v] != <span class="keyword">null</span>)</span><br><span class="line">                spt.addEdge(edgeTo[v]);</span><br><span class="line"></span><br><span class="line">        EdgeWeightedDirectedCycle finder = <span class="keyword">new</span> EdgeWeightedDirectedCycle(spt);</span><br><span class="line">        cycle = finder.cycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴力 Dijkstra 算法也可以求任意两点间的最短路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViolentDijkstra</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[][] edgeTo; <span class="comment">// edgeTo[w][v]: w指向v经过的最后一条边，为了记录路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] distTo;       <span class="comment">// distTo[w][v]: w到v点的路径权重</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViolentDijkstra</span><span class="params">(DirectedGraph graph)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.getV()][graph.getV()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getV()][graph.getV()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; graph.getV(); w++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (w == v)</span><br><span class="line">                    distTo[w][v] = <span class="number">0</span>;  <span class="comment">// 自己指向自己设置为0，为了下面relax()中初始化</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    distTo[w][v] = Double.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Violent Dijkstra algorithm</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; graph.getV(); w++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++) &#123;</span><br><span class="line">                relax(graph,w,v);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工具函数:松弛操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">relax</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> w, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge edge : graph.adj(v)) &#123; <span class="comment">// 遍历所有邻接边</span></span><br><span class="line">            <span class="keyword">int</span> to = edge.to;</span><br><span class="line">            <span class="keyword">if</span> (distTo[w][v] + edge.getWeight() &lt; distTo[w][to]) &#123;</span><br><span class="line">                edgeTo[w][to] = edge;</span><br><span class="line">                distTo[w][to] = distTo[w][v] + edge.getWeight();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[w][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否存在最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[w][v] &lt; Double.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(w, v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;DirectedEdge&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[w][v]; e != <span class="keyword">null</span>; e = edgeTo[w][e.from])</span><br><span class="line">            pathStack.push(e);</span><br><span class="line">        <span class="keyword">return</span> pathStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flyod算法: 动态规划的思想，由于不是基于松弛操作的，所以可以处理负权边</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flyod</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[][] edgeTo; <span class="comment">// edgeTo[w][v]: w指向v经过的最后一条边，为了记录路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[][] distTo;       <span class="comment">// distTo[w][v]: w到v点的路径权重</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyod</span><span class="params">(DirectedGraph graph)</span> </span>&#123;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> DirectedEdge[graph.getV()][graph.getV()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">double</span>[graph.getV()][graph.getV()];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.getV(); i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.getV(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)</span><br><span class="line">                    distTo[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    distTo[i][j] = Double.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : graph.edges()) &#123;</span><br><span class="line">            distTo[e.from][e.to] = e.weight;</span><br><span class="line">            distTo[e.to][e.from] = e.weight;</span><br><span class="line">            edgeTo[e.from][e.to] = e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Flyod algorithm</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; graph.getV(); k++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; graph.getV(); w++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++)</span><br><span class="line">                    <span class="keyword">if</span> (distTo[w][v] &gt; distTo[w][k] + distTo[k][v]) &#123;</span><br><span class="line">                        distTo[w][v] = distTo[w][k] + distTo[k][v];</span><br><span class="line">                        edgeTo[w][v] = graph.getEdge(k,v);  <span class="comment">// 记录边</span></span><br><span class="line">                    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[w][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询是否存在最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> distTo[w][v] &lt; Double.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询最短路径</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(w, v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        LinkedList&lt;DirectedEdge&gt; pathStack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e = edgeTo[w][v]; e != <span class="keyword">null</span>; e = edgeTo[w][e.from])</span><br><span class="line">            pathStack.push(e);</span><br><span class="line">        <span class="keyword">return</span> pathStack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestDirectedGraph</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test UndirectedGraph</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DirectedGraph directedGraph = <span class="keyword">new</span> DirectedGraph(<span class="number">8</span>); <span class="comment">// 添加6个点，ID：0-5</span></span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">30</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">0</span>,<span class="number">5</span>,<span class="number">100</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">50</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">20</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">3</span>,<span class="number">4</span>,<span class="number">60</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(directedGraph);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test Dfs（只添加了6个点）</span></span><br><span class="line">        directedGraph.depthFirstSearch();</span><br><span class="line">        System.out.println(directedGraph.preQueue);</span><br><span class="line">        System.out.println(directedGraph.postQueue);</span><br><span class="line">        System.out.println(directedGraph.reversePostStack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test Dijkstra</span></span><br><span class="line">        Dijkstra dijkstra = <span class="keyword">new</span> Dijkstra(directedGraph,<span class="number">0</span>);</span><br><span class="line">        System.out.println(dijkstra.pathTo(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test AcyclicSP</span></span><br><span class="line">        AcyclicSP acyclicSP = <span class="keyword">new</span> AcyclicSP(directedGraph,<span class="number">0</span>);</span><br><span class="line">        System.out.println(acyclicSP.pathTo(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test Violent Dijkstra</span></span><br><span class="line">        ViolentDijkstra violentDijkstra = <span class="keyword">new</span> ViolentDijkstra(directedGraph);</span><br><span class="line">        System.out.println(violentDijkstra.pathTo(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test Flyod</span></span><br><span class="line">        Flyod flyod = <span class="keyword">new</span> Flyod(directedGraph);</span><br><span class="line">        System.out.println(flyod.pathTo(<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// test BF</span></span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">6</span>,<span class="number">7</span>,-<span class="number">60</span>));</span><br><span class="line">        directedGraph.addEdge(<span class="keyword">new</span> DirectedEdge(<span class="number">7</span>,<span class="number">6</span>,<span class="number">10</span>));</span><br><span class="line">        BellmanFordSP bellmanFordSP = <span class="keyword">new</span> BellmanFordSP(directedGraph,<span class="number">0</span>);</span><br><span class="line">        System.out.println(bellmanFordSP.pathTo(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">[0, 1, 3, 4, 5, 2]</span></span><br><span class="line"><span class="comment">[5, 4, 3, 2, 1, 0]</span></span><br><span class="line"><span class="comment">[0, 1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[DirectedEdge&#123;from=0, to=2, weight=30.0&#125;, DirectedEdge&#123;from=2, to=4, weight=10.0&#125;, DirectedEdge&#123;from=4, to=5, weight=10.0&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[DirectedEdge&#123;from=0, to=2, weight=30.0&#125;, DirectedEdge&#123;from=2, to=4, weight=10.0&#125;, DirectedEdge&#123;from=4, to=5, weight=10.0&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[DirectedEdge&#123;from=0, to=2, weight=30.0&#125;, DirectedEdge&#123;from=2, to=4, weight=10.0&#125;, DirectedEdge&#123;from=4, to=5, weight=10.0&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[DirectedEdge&#123;from=0, to=2, weight=30.0&#125;, DirectedEdge&#123;from=2, to=4, weight=10.0&#125;, DirectedEdge&#123;from=4, to=5, weight=10.0&#125;]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[DirectedEdge&#123;from=0, to=2, weight=30.0&#125;, DirectedEdge&#123;from=2, to=4, weight=10.0&#125;, DirectedEdge&#123;from=4, to=5, weight=10.0&#125;]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexMinPriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] indexPq;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] reIndexQp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IndexMinPriorityQueue</span><span class="params">(<span class="keyword">int</span> maxN)</span> </span>&#123;</span><br><span class="line">        elements = (T[]) <span class="keyword">new</span> Comparable[maxN + <span class="number">1</span>]; <span class="comment">// elements这里可以不加1，没影响，但可能有其他用途</span></span><br><span class="line">        indexPq = <span class="keyword">new</span> <span class="keyword">int</span>[maxN + <span class="number">1</span>];</span><br><span class="line">        reIndexQp = <span class="keyword">new</span> <span class="keyword">int</span>[maxN +<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxN; i++)</span><br><span class="line">            reIndexQp[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> reIndexQp[k] != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入:在k位置插入元素，位置k并不代表任何含义，只是存储在elements数组的索引位置；注意：这里k可以从索引0开始，没有任何影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> k, T value)</span> </span>&#123;</span><br><span class="line">        N++;</span><br><span class="line">        elements[k] = value; <span class="comment">// 放入索引k</span></span><br><span class="line">        indexPq[N] = k;      <span class="comment">// 记录此元素所在索引位置（k）</span></span><br><span class="line">        reIndexQp[k] = N;    <span class="comment">// 记录indexPq数组中哪个位置（N）存储着此元素的索引</span></span><br><span class="line">        swim(N);             <span class="comment">// 从堆底加入并上浮，维护indexPq 和 reIndexQp</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[indexPq[<span class="number">1</span>]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> indexPq[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除最小值，并返回其索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexOfMax = indexPq[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (elements[indexOfMax] == <span class="keyword">null</span>) <span class="comment">// 已为空，返回-1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        exch(<span class="number">1</span>,N--);                 <span class="comment">// 把最后一个元素（最小元素）放在顶端，然后N--(堆的大小-1)</span></span><br><span class="line">        sink(<span class="number">1</span>);                    <span class="comment">// 让“最后”一个元素下沉</span></span><br><span class="line">        elements[indexPq[N+<span class="number">1</span>]] = <span class="keyword">null</span>; <span class="comment">// 将垃圾（删除的最小值）清空</span></span><br><span class="line">        reIndexQp[indexPq[N+<span class="number">1</span>]] = -<span class="number">1</span>;  <span class="comment">// 更新对应reIndexQp为-1</span></span><br><span class="line">        indexPq[N+<span class="number">1</span>] = <span class="number">0</span>;              <span class="comment">// 更新最后一位删除的indexPq为0</span></span><br><span class="line">        <span class="keyword">return</span> indexOfMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引k位置的元素，与删除最小值类似</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> indexOfPq = reIndexQp[k];</span><br><span class="line">        exch(indexOfPq,N--);</span><br><span class="line">        swim(indexOfPq);</span><br><span class="line">        sink(indexOfPq);</span><br><span class="line">        elements[k] = <span class="keyword">null</span>;</span><br><span class="line">        reIndexQp[k] = -<span class="number">1</span>;</span><br><span class="line">        indexPq[N+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> k, T newValue)</span> </span>&#123;</span><br><span class="line">        elements[k] = newValue;</span><br><span class="line">        <span class="comment">// 更新值后，可能出现三种情况：</span></span><br><span class="line">        <span class="comment">//    1. 比父节点小：需要上浮</span></span><br><span class="line">        <span class="comment">//    2. 比子节点大：需要下沉</span></span><br><span class="line">        <span class="comment">//    3. 大小在父节点和子节点之间：不执行任何操作</span></span><br><span class="line">        <span class="comment">// 所以此处采取的策略是先上浮在下沉（或先下沉再上浮）</span></span><br><span class="line">        swim(reIndexQp[k]); <span class="comment">// 上浮</span></span><br><span class="line">        sink(reIndexQp[k]); <span class="comment">// 下沉</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的比较方法：这里怎么设计关乎着是大堆顶(&lt;0)还是小堆顶(&gt;0)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">greater</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elements[indexPq[i]].compareTo(elements[indexPq[j]]) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于堆实现的交换方法：交换indexPq[i]、indexPq[j] 和 reIndexPq[i]、reIndexPq[j]</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tempPq = indexPq[i];</span><br><span class="line">        indexPq[i] = indexPq[j];</span><br><span class="line">        indexPq[j] = tempPq;</span><br><span class="line">        reIndexQp[indexPq[i]] = i;</span><br><span class="line">        reIndexQp[indexPq[j]] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(k &gt; <span class="number">1</span> &amp;&amp; greater(k/<span class="number">2</span>,k)) &#123;</span><br><span class="line">            exch(k/<span class="number">2</span>,k); <span class="comment">// k/2默认向下取整</span></span><br><span class="line">            k = k/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span>*k &lt;= N) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; greater(j,j+<span class="number">1</span>)) <span class="comment">// 找到较小的子节点，并将j指向它</span></span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!greater(k,j)) <span class="comment">// 此时j一定指向较小的子节点，如果elements[indexPq[k]] &lt;= elements[indexPq[j]],则下沉结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            exch(k,j); <span class="comment">// 如果没有break则说明elements[indexPq[k]] &gt; elements[indexPq[j]]，交换indexPq 和 reIndexQp</span></span><br><span class="line">            k = j;     <span class="comment">// 交换k、j，让k始终指向下沉的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;      indexPq &quot;</span> +</span><br><span class="line">                Arrays.toString(indexPq) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    reIndexQp &quot;</span> +</span><br><span class="line">                Arrays.toString(reIndexQp) + <span class="string">&quot;\n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;PriorityQueue &quot;</span> +</span><br><span class="line">                Arrays.toString(elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负权重环检测（环检测只需要把dfs里的weight删除）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EdgeWeightedDirectedCycle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;             <span class="comment">// 是否已经被访问</span></span><br><span class="line">    <span class="keyword">private</span> DirectedEdge[] edgeTo;        <span class="comment">// 到达edgeTo[v]代表达到v的边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] onStack;            <span class="comment">// 递归调用栈上的所有顶点</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;DirectedEdge&gt; cycle;    <span class="comment">// 有向环上的所有顶点（如果存在）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     判断edgeTo[]表示的加权有向图graph是否有环，如果是有，返回环。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EdgeWeightedDirectedCycle</span><span class="params">(DirectedGraph graph)</span> </span>&#123;</span><br><span class="line">        marked  = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getV()];</span><br><span class="line">        onStack = <span class="keyword">new</span> <span class="keyword">boolean</span>[graph.getV()];</span><br><span class="line">        edgeTo  = <span class="keyword">new</span> DirectedEdge[graph.getV()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; graph.getV(); v++)</span><br><span class="line">            <span class="keyword">if</span> (!marked[v]) dfs(graph, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfs查找环</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(DirectedGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        onStack[v] = <span class="keyword">true</span>;  <span class="comment">// 标记已经在栈上了</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (DirectedEdge e : graph.adj(v)) &#123;</span><br><span class="line">            <span class="keyword">int</span> w = e.to;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cycle != <span class="keyword">null</span>) <span class="keyword">return</span>; <span class="comment">// 已经有环了，返回</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!marked[w]) &#123;     <span class="comment">// 找到没有被访问的点，递归 dfs</span></span><br><span class="line">                edgeTo[w] = e;</span><br><span class="line">                dfs(graph, w);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (onStack[w]) &#123;    <span class="comment">// 如果相邻点已经在同一个栈上了，则说明存在环，并记录这个环</span></span><br><span class="line">                cycle = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                <span class="keyword">double</span> weight = <span class="number">0</span>; <span class="comment">// 计算环的权值（前面如果是拓扑排序请把这部分删除）</span></span><br><span class="line"></span><br><span class="line">                DirectedEdge f = e;</span><br><span class="line">                <span class="keyword">while</span> (f.from != w) &#123; <span class="comment">// 循环遍历这个环，加入cycle中</span></span><br><span class="line">                    cycle.push(f);</span><br><span class="line">                    weight += f.getWeight();</span><br><span class="line">                    f = edgeTo[f.from];</span><br><span class="line">                &#125;</span><br><span class="line">                cycle.push(f);</span><br><span class="line">                weight = weight + f.getWeight();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) <span class="comment">// 正权值环</span></span><br><span class="line">                    cycle = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 添加完环返回</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        onStack[v] = <span class="keyword">false</span>; <span class="comment">// 递归结束要出栈，将入栈标记标为 false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="title">cycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cycle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Dijkstra/" rel="tag"><i class="fa fa-tag"></i> Dijkstra</a>
              <a href="/tags/Bellman-Ford/" rel="tag"><i class="fa fa-tag"></i> Bellman-Ford</a>
              <a href="/tags/Flyod/" rel="tag"><i class="fa fa-tag"></i> Flyod</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/08/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%8A%A0%E6%9D%83%E6%97%A0%E5%90%91%E5%9B%BE/" rel="prev" title="加权无向图的遍历（DFS、BFS）和最小生成树(Prim、Kruskal)">
                  <i class="fa fa-chevron-left"></i> 加权无向图的遍历（DFS、BFS）和最小生成树(Prim、Kruskal)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/09/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95_%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98/" rel="next" title="动态规划问题">
                  动态规划问题 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>





<script src="/js/comments.js"></script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2018 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Saltedfish</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">408k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:22</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
